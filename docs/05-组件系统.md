# 组件系统

## 1. 组件模型设计

组件是低代码编辑器的核心元素，良好的组件模型设计是实现高效编辑和灵活扩展的基础。

### 1.1 组件模型原则

我们的组件模型设计遵循以下原则：

1. **统一抽象**：所有组件共享相同的基础结构，便于统一处理
2. **可组合性**：组件可以灵活组合，形成复杂的页面结构
3. **属性驱动**：通过属性控制组件的外观和行为
4. **样式隔离**：组件样式相互隔离，避免冲突
5. **事件标准化**：统一的事件处理机制
6. **可扩展性**：支持自定义组件和第三方组件集成

### 1.2 组件Schema定义

```typescript
/**
 * 组件Schema - 组件的数据模型
 */
interface ComponentSchema {
  // 基本信息
  id: string;                  // 组件唯一ID
  type: string;                // 组件类型标识
  name?: string;               // 组件实例名称（用户可自定义）
  
  // 数据与样式
  props: Record<string, any>;  // 组件属性
  style: CSSProperties;        // 样式属性
  
  // 结构信息
  children?: string[];         // 子组件ID列表
  parentId?: string;           // 父组件ID
  
  // 交互信息
  events?: EventMap;           // 事件映射
  actions?: ActionMap;         // 动作映射
  
  // 布局信息
  layout?: {
    position?: 'static' | 'relative' | 'absolute' | 'fixed';
    x?: number;
    y?: number;
    width?: number | string;
    height?: number | string;
    zIndex?: number;
    constraints?: LayoutConstraints;
  };
  
  // 响应式配置
  responsive?: {
    rules: ResponsiveRule[];
  };
  
  // 元信息
  meta?: {
    label: string;             // 显示名称
    icon?: string;             // 组件图标
    category: string;          // 分类
    description?: string;      // 描述
    tags?: string[];           // 标签
    hidden?: boolean;          // 是否在大纲中隐藏
    locked?: boolean;          // 是否锁定不可编辑
  };
  
  // 数据绑定
  dataBindings?: DataBindings; // 数据绑定配置
  
  // 验证规则
  validations?: ValidationRule[]; // 验证规则
  
  // 自定义数据
  customData?: Record<string, any>; // 组件特定的自定义数据
}

// 事件映射
interface EventMap {
  [eventName: string]: {
    type: 'function' | 'navigation' | 'state' | 'api';
    handler: string;
    params?: Record<string, any>;
  };
}

// 动作映射
interface ActionMap {
  [actionName: string]: {
    type: 'function' | 'navigation' | 'state' | 'api';
    handler: string;
    params?: Record<string, any>;
  };
}

// 数据绑定
interface DataBindings {
  [propPath: string]: {
    type: 'state' | 'api' | 'computed' | 'context';
    source: string;
    transform?: string;
    fallback?: any;
  };
}

// 响应式规则
interface ResponsiveRule {
  breakpoint: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  style?: Partial<CSSProperties>;
  props?: Record<string, any>;
  hidden?: boolean;
}

// 验证规则
interface ValidationRule {
  field: string;
  type: 'required' | 'pattern' | 'min' | 'max' | 'custom';
  value?: any;
  message?: string;
  validator?: string;
}
```

### 1.3 组件类型定义

每种组件类型都需要有明确的定义，包括其属性、事件和行为：

```typescript
/**
 * 组件类型定义
 */
interface ComponentDefinition {
  // 基本信息
  type: string;                 // 组件类型唯一标识
  name: string;                 // 组件类型名称
  category: string;             // 组件分类
  icon?: string;                // 组件图标
  description?: string;         // 组件描述
  
  // 默认值
  defaultProps?: Record<string, any>; // 默认属性
  defaultStyle?: CSSProperties;       // 默认样式
  
  // 属性定义
  propDefinitions: PropDefinition[];  // 属性定义列表
  
  // 事件定义
  eventDefinitions?: EventDefinition[]; // 事件定义列表
  
  // 行为定义
  behavior?: {
    isContainer?: boolean;      // 是否可以包含子组件
    allowedChildren?: string[]; // 允许的子组件类型
    maxChildren?: number;       // 最大子组件数量
    canHaveChildren?: boolean;  // 是否可以有子组件
    isLayout?: boolean;         // 是否是布局组件
    droppable?: boolean;        // 是否可以放置其他组件
    draggable?: boolean;        // 是否可以拖动
    resizable?: boolean;        // 是否可以调整大小
    selectable?: boolean;       // 是否可以选择
  };
  
  // 渲染器信息
  renderer: {
    component: React.ComponentType<any>; // 组件渲染器
    editableAreas?: EditableAreaDefinition[]; // 可编辑区域定义
  };
  
  // 依赖配置
  dependencies?: string[];      // 依赖的其他组件或库
}

// 属性定义
interface PropDefinition {
  name: string;                 // 属性名
  label: string;                // 属性标签（显示名）
  type: PropType;               // 属性类型
  defaultValue?: any;           // 默认值
  required?: boolean;           // 是否必需
  description?: string;         // 描述
  options?: PropOption[];       // 选项（用于select、radio等）
  group?: string;               // 分组
  condition?: PropCondition;    // 显示条件
  min?: number;                 // 最小值（用于number）
  max?: number;                 // 最大值（用于number）
  step?: number;                // 步长（用于number）
  placeholder?: string;         // 占位符
  hidden?: boolean;             // 是否在属性面板中隐藏
}

// 属性类型
type PropType = 
  | 'string'        // 字符串
  | 'number'        // 数字
  | 'boolean'       // 布尔
  | 'select'        // 选择器
  | 'radio'         // 单选
  | 'checkbox'      // 复选
  | 'color'         // 颜色
  | 'image'         // 图片
  | 'icon'          // 图标
  | 'date'          // 日期
  | 'time'          // 时间
  | 'json'          // JSON
  | 'code'          // 代码
  | 'expression'    // 表达式
  | 'richText'      // 富文本
  | 'array'         // 数组
  | 'object'        // 对象
  | 'component'     // 组件引用
  | 'datasource'    // 数据源
  | 'custom';       // 自定义

// 事件定义
interface EventDefinition {
  name: string;                 // 事件名
  label: string;                // 事件标签
  description?: string;         // 描述
  params?: EventParamDefinition[]; // 事件参数
}

// 事件参数定义
interface EventParamDefinition {
  name: string;                 // 参数名
  type: string;                 // 参数类型
  description?: string;         // 描述
}

// 可编辑区域定义
interface EditableAreaDefinition {
  name: string;                 // 区域名
  selector: string;             // CSS选择器
  allowedChildren?: string[];   // 允许的子组件类型
}
```

## 2. 基础组件库

我们的低代码编辑器提供丰富的基础组件库，满足各种常见的UI构建需求。

### 2.1 组件分类

基础组件库按照功能划分为以下几类：

1. **布局组件**：用于构建页面结构和布局
2. **基础UI组件**：基本的UI元素
3. **表单组件**：用于数据收集和表单交互
4. **数据展示组件**：展示各类数据内容
5. **导航组件**：页面导航和菜单组件
6. **反馈组件**：提供用户反馈和通知
7. **容器组件**：包含其他组件的容器
8. **高级组件**：复杂功能的组合组件

### 2.2 布局组件

布局组件是构建页面结构的基础，支持各种布局方式。

#### 2.2.1 Flex容器

```typescript
// Flex容器组件定义
const FlexContainerDefinition: ComponentDefinition = {
  type: 'flex-container',
  name: 'Flex布局容器',
  category: '布局组件',
  icon: 'layout-icon',
  description: '基于Flex的弹性布局容器',
  
  defaultProps: {
    direction: 'row',
    justifyContent: 'flex-start',
    alignItems: 'stretch',
    flexWrap: 'nowrap',
    gap: '0',
  },
  
  defaultStyle: {
    width: '100%',
    minHeight: '100px',
  },
  
  propDefinitions: [
    {
      name: 'direction',
      label: '排列方向',
      type: 'select',
      defaultValue: 'row',
      options: [
        { label: '水平排列', value: 'row' },
        { label: '水平反向排列', value: 'row-reverse' },
        { label: '垂直排列', value: 'column' },
        { label: '垂直反向排列', value: 'column-reverse' },
      ],
      group: '布局',
    },
    {
      name: 'justifyContent',
      label: '主轴对齐',
      type: 'select',
      defaultValue: 'flex-start',
      options: [
        { label: '起始对齐', value: 'flex-start' },
        { label: '居中对齐', value: 'center' },
        { label: '末尾对齐', value: 'flex-end' },
        { label: '两端对齐', value: 'space-between' },
        { label: '均匀分布', value: 'space-around' },
        { label: '等间距分布', value: 'space-evenly' },
      ],
      group: '布局',
    },
    {
      name: 'alignItems',
      label: '交叉轴对齐',
      type: 'select',
      defaultValue: 'stretch',
      options: [
        { label: '拉伸填充', value: 'stretch' },
        { label: '起始对齐', value: 'flex-start' },
        { label: '居中对齐', value: 'center' },
        { label: '末尾对齐', value: 'flex-end' },
        { label: '文本基线对齐', value: 'baseline' },
      ],
      group: '布局',
    },
    {
      name: 'flexWrap',
      label: '换行方式',
      type: 'select',
      defaultValue: 'nowrap',
      options: [
        { label: '不换行', value: 'nowrap' },
        { label: '换行', value: 'wrap' },
        { label: '反向换行', value: 'wrap-reverse' },
      ],
      group: '布局',
    },
    {
      name: 'gap',
      label: '间距',
      type: 'string',
      defaultValue: '0',
      group: '布局',
    },
    // 其他属性...
  ],
  
  behavior: {
    isContainer: true,
    allowedChildren: ['*'], // 允许任何组件作为子组件
    isLayout: true,
    droppable: true,
    draggable: true,
    resizable: true,
  },
  
  renderer: {
    component: FlexContainer, // 实际渲染组件
  },
};
```

#### 2.2.2 网格容器

```typescript
// 网格容器组件定义
const GridContainerDefinition: ComponentDefinition = {
  type: 'grid-container',
  name: '网格布局容器',
  category: '布局组件',
  icon: 'grid-icon',
  description: '基于CSS Grid的网格布局容器',
  
  defaultProps: {
    columns: '1fr 1fr 1fr',
    rows: 'auto',
    gap: '16px',
    areas: '',
  },
  
  defaultStyle: {
    width: '100%',
    minHeight: '200px',
  },
  
  propDefinitions: [
    {
      name: 'columns',
      label: '列定义',
      type: 'string',
      defaultValue: '1fr 1fr 1fr',
      description: '网格列的定义，如"1fr 1fr 1fr"表示三等分',
      group: '布局',
    },
    {
      name: 'rows',
      label: '行定义',
      type: 'string',
      defaultValue: 'auto',
      description: '网格行的定义',
      group: '布局',
    },
    {
      name: 'gap',
      label: '间距',
      type: 'string',
      defaultValue: '16px',
      description: '网格单元格之间的间距',
      group: '布局',
    },
    {
      name: 'areas',
      label: '区域模板',
      type: 'code',
      defaultValue: '',
      description: '网格区域模板定义',
      group: '布局',
    },
    // 其他属性...
  ],
  
  behavior: {
    isContainer: true,
    allowedChildren: ['*'],
    isLayout: true,
    droppable: true,
    draggable: true,
    resizable: true,
  },
  
  renderer: {
    component: GridContainer,
  },
};
```

#### 2.2.3 响应式容器

```typescript
// 响应式容器组件定义
const ResponsiveContainerDefinition: ComponentDefinition = {
  type: 'responsive-container',
  name: '响应式容器',
  category: '布局组件',
  icon: 'responsive-icon',
  description: '根据屏幕尺寸自动调整布局的容器',
  
  defaultProps: {
    breakpoints: {
      xs: { columns: 1 },
      sm: { columns: 2 },
      md: { columns: 3 },
      lg: { columns: 4 },
      xl: { columns: 5 },
    },
    gap: '16px',
  },
  
  defaultStyle: {
    width: '100%',
  },
  
  propDefinitions: [
    {
      name: 'breakpoints',
      label: '响应式断点',
      type: 'object',
      defaultValue: {
        xs: { columns: 1 },
        sm: { columns: 2 },
        md: { columns: 3 },
        lg: { columns: 4 },
        xl: { columns: 5 },
      },
      group: '响应式',
    },
    {
      name: 'gap',
      label: '间距',
      type: 'string',
      defaultValue: '16px',
      group: '布局',
    },
    // 其他属性...
  ],
  
  behavior: {
    isContainer: true,
    allowedChildren: ['*'],
    isLayout: true,
    droppable: true,
    draggable: true,
    resizable: true,
  },
  
  renderer: {
    component: ResponsiveContainer,
  },
};
```

### 2.3 基础UI组件

基础UI组件是构建页面内容的基本元素。

#### 2.3.1 文本组件

```typescript
// 文本组件定义
const TextDefinition: ComponentDefinition = {
  type: 'text',
  name: '文本',
  category: '基础组件',
  icon: 'text-icon',
  description: '用于显示文本内容',
  
  defaultProps: {
    content: '文本内容',
    tag: 'p',
  },
  
  defaultStyle: {
    fontSize: '16px',
    lineHeight: '1.5',
    margin: '0',
  },
  
  propDefinitions: [
    {
      name: 'content',
      label: '文本内容',
      type: 'richText',
      defaultValue: '文本内容',
      group: '内容',
    },
    {
      name: 'tag',
      label: 'HTML标签',
      type: 'select',
      defaultValue: 'p',
      options: [
        { label: '段落(p)', value: 'p' },
        { label: '标题1(h1)', value: 'h1' },
        { label: '标题2(h2)', value: 'h2' },
        { label: '标题3(h3)', value: 'h3' },
        { label: '标题4(h4)', value: 'h4' },
        { label: '标题5(h5)', value: 'h5' },
        { label: '标题6(h6)', value: 'h6' },
        { label: '内联文本(span)', value: 'span' },
        { label: '块引用(blockquote)', value: 'blockquote' },
      ],
      group: '外观',
    },
    // 其他属性...
  ],
  
  behavior: {
    isContainer: false,
    draggable: true,
    resizable: false,
    selectable: true,
  },
  
  renderer: {
    component: Text,
  },
};
```

#### 2.3.2 图片组件

```typescript
// 图片组件定义
const ImageDefinition: ComponentDefinition = {
  type: 'image',
  name: '图片',
  category: '基础组件',
  icon: 'image-icon',
  description: '用于显示图片',
  
  defaultProps: {
    src: '',
    alt: '图片描述',
    objectFit: 'cover',
    lazy: true,
  },
  
  defaultStyle: {
    width: '100%',
    height: 'auto',
  },
  
  propDefinitions: [
    {
      name: 'src',
      label: '图片地址',
      type: 'image',
      defaultValue: '',
      group: '内容',
    },
    {
      name: 'alt',
      label: '替代文本',
      type: 'string',
      defaultValue: '图片描述',
      description: '图片无法显示时的替代文本，对无障碍访问很重要',
      group: '内容',
    },
    {
      name: 'objectFit',
      label: '填充方式',
      type: 'select',
      defaultValue: 'cover',
      options: [
        { label: '覆盖(cover)', value: 'cover' },
        { label: '包含(contain)', value: 'contain' },
        { label: '填充(fill)', value: 'fill' },
        { label: '保持原始尺寸(none)', value: 'none' },
        { label: '缩放到合适大小(scale-down)', value: 'scale-down' },
      ],
      group: '外观',
    },
    {
      name: 'lazy',
      label: '懒加载',
      type: 'boolean',
      defaultValue: true,
      description: '是否启用懒加载',
      group: '性能',
    },
    // 其他属性...
  ],
  
  behavior: {
    isContainer: false,
    draggable: true,
    resizable: true,
    selectable: true,
  },
  
  renderer: {
    component: Image,
  },
};
```

#### 2.3.3 按钮组件

```typescript
// 按钮组件定义
const ButtonDefinition: ComponentDefinition = {
  type: 'button',
  name: '按钮',
  category: '基础组件',
  icon: 'button-icon',
  description: '可点击的按钮',
  
  defaultProps: {
    text: '按钮',
    variant: 'primary',
    size: 'medium',
    disabled: false,
    icon: '',
    iconPosition: 'left',
  },
  
  defaultStyle: {
    borderRadius: '4px',
  },
  
  propDefinitions: [
    {
      name: 'text',
      label: '按钮文本',
      type: 'string',
      defaultValue: '按钮',
      group: '内容',
    },
    {
      name: 'variant',
      label: '样式风格',
      type: 'select',
      defaultValue: 'primary',
      options: [
        { label: '主要按钮', value: 'primary' },
        { label: '次要按钮', value: 'secondary' },
        { label: '文本按钮', value: 'text' },
        { label: '链接按钮', value: 'link' },
        { label: '成功按钮', value: 'success' },
        { label: '警告按钮', value: 'warning' },
        { label: '危险按钮', value: 'danger' },
      ],
      group: '外观',
    },
    {
      name: 'size',
      label: '尺寸',
      type: 'select',
      defaultValue: 'medium',
      options: [
        { label: '小', value: 'small' },
        { label: '中', value: 'medium' },
        { label: '大', value: 'large' },
      ],
      group: '外观',
    },
    {
      name: 'disabled',
      label: '禁用',
      type: 'boolean',
      defaultValue: false,
      group: '状态',
    },
    {
      name: 'icon',
      label: '图标',
      type: 'icon',
      defaultValue: '',
      group: '内容',
    },
    {
      name: 'iconPosition',
      label: '图标位置',
      type: 'select',
      defaultValue: 'left',
      options: [
        { label: '左侧', value: 'left' },
        { label: '右侧', value: 'right' },
      ],
      group: '内容',
      condition: {
        field: 'icon',
        operator: '!=',
        value: '',
      },
    },
    // 其他属性...
  ],
  
  eventDefinitions: [
    {
      name: 'onClick',
      label: '点击事件',
      description: '按钮被点击时触发',
    },
  ],
  
  behavior: {
    isContainer: false,
    draggable: true,
    resizable: false,
    selectable: true,
  },
  
  renderer: {
    component: Button,
  },
};
```

### 2.4 表单组件

表单组件用于收集用户输入的数据。

#### 2.4.1 输入框组件

```typescript
// 输入框组件定义
const InputDefinition: ComponentDefinition = {
  type: 'input',
  name: '输入框',
  category: '表单组件',
  icon: 'input-icon',
  description: '单行文本输入框',
  
  defaultProps: {
    placeholder: '请输入',
    type: 'text',
    label: '输入框',
    required: false,
    disabled: false,
    readOnly: false,
    defaultValue: '',
    maxLength: '',
    showCount: false,
  },
  
  defaultStyle: {
    width: '100%',
  },
  
  propDefinitions: [
    {
      name: 'placeholder',
      label: '占位提示',
      type: 'string',
      defaultValue: '请输入',
      group: '基本',
    },
    {
      name: 'type',
      label: '输入类型',
      type: 'select',
      defaultValue: 'text',
      options: [
        { label: '文本', value: 'text' },
        { label: '密码', value: 'password' },
        { label: '数字', value: 'number' },
        { label: '电子邮件', value: 'email' },
        { label: '电话号码', value: 'tel' },
        { label: '网址', value: 'url' },
        { label: '搜索', value: 'search' },
      ],
      group: '基本',
    },
    {
      name: 'label',
      label: '标签文本',
      type: 'string',
      defaultValue: '输入框',
      group: '基本',
    },
    {
      name: 'required',
      label: '必填',
      type: 'boolean',
      defaultValue: false,
      group: '验证',
    },
    {
      name: 'disabled',
      label: '禁用',
      type: 'boolean',
      defaultValue: false,
      group: '状态',
    },
    {
      name: 'readOnly',
      label: '只读',
      type: 'boolean',
      defaultValue: false,
      group: '状态',
    },
    {
      name: 'defaultValue',
      label: '默认值',
      type: 'string',
      defaultValue: '',
      group: '基本',
    },
    {
      name: 'maxLength',
      label: '最大长度',
      type: 'number',
      defaultValue: '',
      group: '验证',
    },
    {
      name: 'showCount',
      label: '显示计数',
      type: 'boolean',
      defaultValue: false,
      group: '外观',
    },
    // 其他属性...
  ],
  
  eventDefinitions: [
    {
      name: 'onChange',
      label: '值变化',
      description: '输入值变化时触发',
      params: [
        {
          name: 'value',
          type: 'string',
          description: '当前输入值',
        },
      ],
    },
    {
      name: 'onFocus',
      label: '获得焦点',
      description: '输入框获得焦点时触发',
    },
    {
      name: 'onBlur',
      label: '失去焦点',
      description: '输入框失去焦点时触发',
    },
    {
      name: 'onPressEnter',
      label: '按下回车',
      description: '在输入框中按下回车键时触发',
    },
  ],
  
  validations: [
    {
      field: 'value',
      type: 'required',
      message: '请输入内容',
      condition: {
        field: 'required',
        operator: '==',
        value: true,
      },
    },
  ],
  
  behavior: {
    isContainer: false,
    draggable: true,
    resizable: true,
    selectable: true,
  },
  
  renderer: {
    component: Input,
  },
};
```

#### 2.4.2 选择器组件

```typescript
// 选择器组件定义
const SelectDefinition: ComponentDefinition = {
  type: 'select',
  name: '选择器',
  category: '表单组件',
  icon: 'select-icon',
  description: '下拉选择器',
  
  defaultProps: {
    placeholder: '请选择',
    label: '选择器',
    options: [
      { label: '选项1', value: '1' },
      { label: '选项2', value: '2' },
      { label: '选项3', value: '3' },
    ],
    required: false,
    disabled: false,
    multiple: false,
    allowClear: true,
    defaultValue: undefined,
  },
  
  defaultStyle: {
    width: '100%',
  },
  
  propDefinitions: [
    {
      name: 'placeholder',
      label: '占位提示',
      type: 'string',
      defaultValue: '请选择',
      group: '基本',
    },
    {
      name: 'label',
      label: '标签文本',
      type: 'string',
      defaultValue: '选择器',
      group: '基本',
    },
    {
      name: 'options',
      label: '选项列表',
      type: 'array',
      defaultValue: [
        { label: '选项1', value: '1' },
        { label: '选项2', value: '2' },
        { label: '选项3', value: '3' },
      ],
      group: '数据',
    },
    {
      name: 'required',
      label: '必选',
      type: 'boolean',
      defaultValue: false,
      group: '验证',
    },
    {
      name: 'disabled',
      label: '禁用',
      type: 'boolean',
      defaultValue: false,
      group: '状态',
    },
    {
      name: 'multiple',
      label: '多选',
      type: 'boolean',
      defaultValue: false,
      group: '基本',
    },
    {
      name: 'allowClear',
      label: '允许清除',
      type: 'boolean',
      defaultValue: true,
      group: '基本',
    },
    {
      name: 'defaultValue',
      label: '默认值',
      type: 'string',
      defaultValue: undefined,
      group: '基本',
    },
    // 其他属性...
  ],
  
  eventDefinitions: [
    {
      name: 'onChange',
      label: '选择变化',
      description: '选中值变化时触发',
      params: [
        {
          name: 'value',
          type: 'string | string[]',
          description: '当前选中值',
        },
      ],
    },
    {
      name: 'onFocus',
      label: '获得焦点',
      description: '选择器获得焦点时触发',
    },
    {
      name: 'onBlur',
      label: '失去焦点',
      description: '选择器失去焦点时触发',
    },
  ],
  
  behavior: {
    isContainer: false,
    draggable: true,
    resizable: true,
    selectable: true,
  },
  
  renderer: {
    component: Select,
  },
};
```

## 3. 组件属性面板

组件属性面板是低代码编辑器中用户配置组件的主要界面，提供直观的属性编辑功能。

### 3.1 属性面板架构

属性面板的架构设计如下：

```
+-------------------+
|    属性面板容器    |
| PropertyPanel    |
+-------------------+
         |
         v
+-------------------+
|    属性分组       |
| PropertyGroup    |
+-------------------+
         |
         v
+-------------------+      +-------------------+
|   基础属性编辑器   |      |   高级属性编辑器   |
| BasicPropEditor  |      | AdvancedPropEditor|
+-------------------+      +-------------------+
         |                          |
         v                          v
+-------------------+      +-------------------+
|   属性渲染器       |      |    特殊编辑器     |
| PropertyRenderer  |      | SpecialEditor    |
+-------------------+      +-------------------+
```

### 3.2 属性面板实现

#### 3.2.1 属性面板组件

```tsx
/**
 * 属性面板组件
 */
interface PropertyPanelProps {
  componentId: string | null;
}

function PropertyPanel({ componentId }: PropertyPanelProps) {
  // 从状态管理中获取选中的组件数据
  const selectedComponent = useEditorStore(state => 
    componentId ? state.components.byId[componentId] : null
  );
  
  // 获取组件定义
  const componentDefinition = useComponentRegistry(registry => 
    selectedComponent ? registry.getDefinition(selectedComponent.type) : null
  );
  
  // 分组属性
  const groupedProps = useMemo(() => {
    if (!componentDefinition) return {};
    
    return groupPropsByCategory(componentDefinition.propDefinitions);
  }, [componentDefinition]);
  
  // 组件更新处理
  const handlePropertyChange = useCallback((propName: string, value: any) => {
    if (!componentId) return;
    
    // 更新组件属性
    editorActions.updateComponent(componentId, {
      props: { [propName]: value }
    });
  }, [componentId]);
  
  // 样式更新处理
  const handleStyleChange = useCallback((styleProp: string, value: any) => {
    if (!componentId) return;
    
    // 更新组件样式
    editorActions.updateComponent(componentId, {
      style: { [styleProp]: value }
    });
  }, [componentId]);
  
  if (!selectedComponent || !componentDefinition) {
    return (
      <div className="property-panel property-panel-empty">
        <div className="empty-message">请选择一个组件</div>
      </div>
    );
  }
  
  return (
    <div className="property-panel">
      <div className="property-panel-header">
        <div className="component-icon">
          {getComponentIcon(componentDefinition.icon)}
        </div>
        <div className="component-info">
          <div className="component-name">{componentDefinition.name}</div>
          <div className="component-id">{componentId}</div>
        </div>
      </div>
      
      <div className="property-panel-content">
        {/* 属性分组 */}
        {Object.entries(groupedProps).map(([group, props]) => (
          <PropertyGroup 
            key={group}
            title={group}
            properties={props}
            component={selectedComponent}
            onChange={handlePropertyChange}
          />
        ))}
        
        {/* 样式编辑器 */}
        <StyleEditor 
          style={selectedComponent.style}
          onChange={handleStyleChange}
        />
        
        {/* 事件编辑器 */}
        {componentDefinition.eventDefinitions && (
          <EventEditor 
            events={selectedComponent.events || {}}
            definitions={componentDefinition.eventDefinitions}
            onChange={handleEventChange}
            componentId={componentId}
          />
        )}
      </div>
    </div>
  );
}
```

#### 3.2.2 属性分组组件

```tsx
/**
 * 属性分组组件
 */
interface PropertyGroupProps {
  title: string;
  properties: PropDefinition[];
  component: ComponentSchema;
  onChange: (propName: string, value: any) => void;
}

function PropertyGroup({ title, properties, component, onChange }: PropertyGroupProps) {
  const [isExpanded, setIsExpanded] = useState(true);
  
  // 切换展开/折叠状态
  const toggleExpand = () => setIsExpanded(!isExpanded);
  
  return (
    <div className={`property-group ${isExpanded ? 'expanded' : 'collapsed'}`}>
      <div className="property-group-header" onClick={toggleExpand}>
        <div className="group-title">{title}</div>
        <div className="group-toggle">
          {isExpanded ? <ChevronUpIcon /> : <ChevronDownIcon />}
        </div>
      </div>
      
      {isExpanded && (
        <div className="property-group-content">
          {properties.map(propDef => {
            // 检查条件属性是否满足
            if (propDef.condition && !evaluateCondition(propDef.condition, component.props)) {
              return null;
            }
            
            // 检查是否隐藏
            if (propDef.hidden) {
              return null;
            }
            
            const currentValue = component.props[propDef.name];
            
            return (
              <PropertyEditor
                key={propDef.name}
                definition={propDef}
                value={currentValue}
                onChange={(value) => onChange(propDef.name, value)}
              />
            );
          })}
        </div>
      )}
    </div>
  );
}
```

#### 3.2.3 属性编辑器组件

```tsx
/**
 * 属性编辑器组件 - 根据属性类型选择适当的编辑器
 */
interface PropertyEditorProps {
  definition: PropDefinition;
  value: any;
  onChange: (value: any) => void;
}

function PropertyEditor({ definition, value, onChange }: PropertyEditorProps) {
  // 根据属性类型选择合适的编辑器
  const renderEditor = () => {
    switch (definition.type) {
      case 'string':
        return (
          <StringEditor
            value={value}
            onChange={onChange}
            placeholder={definition.placeholder}
          />
        );
        
      case 'number':
        return (
          <NumberEditor
            value={value}
            onChange={onChange}
            min={definition.min}
            max={definition.max}
            step={definition.step}
          />
        );
        
      case 'boolean':
        return (
          <BooleanEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'select':
        return (
          <SelectEditor
            value={value}
            options={definition.options || []}
            onChange={onChange}
          />
        );
        
      case 'color':
        return (
          <ColorEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'image':
        return (
          <ImageEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'richText':
        return (
          <RichTextEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'code':
        return (
          <CodeEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'array':
        return (
          <ArrayEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'object':
        return (
          <ObjectEditor
            value={value}
            onChange={onChange}
          />
        );
        
      case 'icon':
        return (
          <IconEditor
            value={value}
            onChange={onChange}
          />
        );
        
      // 其他编辑器类型...
        
      default:
        return (
          <StringEditor
            value={value}
            onChange={onChange}
            placeholder={definition.placeholder}
          />
        );
    }
  };
  
  return (
    <div className="property-editor">
      <div className="property-label">
        {definition.label}
        {definition.required && <span className="required-mark">*</span>}
        {definition.description && (
          <Tooltip title={definition.description}>
            <InfoCircleIcon className="help-icon" />
          </Tooltip>
        )}
      </div>
      <div className="property-input">
        {renderEditor()}
      </div>
    </div>
  );
}
```

### 3.3 高级属性编辑器

除了基础的属性编辑器外，我们还提供一些高级编辑器来处理复杂属性。

#### 3.3.1 样式编辑器

```tsx
/**
 * 样式编辑器组件
 */
interface StyleEditorProps {
  style: CSSProperties;
  onChange: (property: string, value: any) => void;
}

function StyleEditor({ style, onChange }: StyleEditorProps) {
  const [activeTab, setActiveTab] = useState('layout');
  
  // 样式分类
  const styleCategories = {
    layout: [
      { name: 'width', label: '宽度', type: 'size' },
      { name: 'height', label: '高度', type: 'size' },
      { name: 'display', label: '显示模式', type: 'select', options: [
        { label: '块级', value: 'block' },
        { label: '行内', value: 'inline' },
        { label: '行内块', value: 'inline-block' },
        { label: '弹性盒', value: 'flex' },
        { label: '网格', value: 'grid' },
        { label: '隐藏', value: 'none' },
      ]},
      { name: 'position', label: '定位', type: 'select', options: [
        { label: '静态', value: 'static' },
        { label: '相对', value: 'relative' },
        { label: '绝对', value: 'absolute' },
        { label: '固定', value: 'fixed' },
        { label: '粘性', value: 'sticky' },
      ]},
      // 其他布局属性...
    ],
    typography: [
      { name: 'fontFamily', label: '字体', type: 'string' },
      { name: 'fontSize', label: '字号', type: 'size' },
      { name: 'fontWeight', label: '字重', type: 'select', options: [
        { label: '普通', value: 'normal' },
        { label: '粗体', value: 'bold' },
        { label: '更粗', value: '800' },
        { label: '更细', value: '300' },
      ]},
      { name: 'lineHeight', label: '行高', type: 'size' },
      { name: 'color', label: '文本颜色', type: 'color' },
      { name: 'textAlign', label: '对齐方式', type: 'select', options: [
        { label: '左对齐', value: 'left' },
        { label: '居中', value: 'center' },
        { label: '右对齐', value: 'right' },
        { label: '两端对齐', value: 'justify' },
      ]},
      // 其他排版属性...
    ],
    background: [
      { name: 'backgroundColor', label: '背景色', type: 'color' },
      { name: 'backgroundImage', label: '背景图', type: 'image' },
      { name: 'backgroundSize', label: '背景尺寸', type: 'select', options: [
        { label: '覆盖', value: 'cover' },
        { label: '包含', value: 'contain' },
        { label: '自动', value: 'auto' },
      ]},
      // 其他背景属性...
    ],
    border: [
      { name: 'borderStyle', label: '边框样式', type: 'select', options: [
        { label: '无', value: 'none' },
        { label: '实线', value: 'solid' },
        { label: '虚线', value: 'dashed' },
        { label: '点线', value: 'dotted' },
      ]},
      { name: 'borderWidth', label: '边框宽度', type: 'size' },
      { name: 'borderColor', label: '边框颜色', type: 'color' },
      { name: 'borderRadius', label: '圆角', type: 'size' },
      // 其他边框属性...
    ],
    spacing: [
      { name: 'margin', label: '外边距', type: 'spacing' },
      { name: 'padding', label: '内边距', type: 'spacing' },
      // 其他间距属性...
    ],
    effects: [
      { name: 'boxShadow', label: '阴影', type: 'shadow' },
      { name: 'opacity', label: '不透明度', type: 'number', min: 0, max: 1, step: 0.01 },
      // 其他效果属性...
    ],
  };
  
  return (
    <div className="style-editor">
      <div className="style-editor-header">
        <div className="tabs">
          {Object.keys(styleCategories).map(category => (
            <div 
              key={category}
              className={`tab ${activeTab === category ? 'active' : ''}`}
              onClick={() => setActiveTab(category)}
            >
              {capitalizeFirstLetter(category)}
            </div>
          ))}
        </div>
      </div>
      
      <div className="style-editor-content">
        {styleCategories[activeTab].map(prop => {
          const currentValue = style[prop.name];
          
          return (
            <div key={prop.name} className="style-property">
              <div className="style-property-label">{prop.label}</div>
              <div className="style-property-input">
                <StylePropertyEditor
                  type={prop.type}
                  value={currentValue}
                  onChange={(value) => onChange(prop.name, value)}
                  options={prop.options}
                  min={prop.min}
                  max={prop.max}
                  step={prop.step}
                />
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

#### 3.3.2 事件编辑器

```tsx
/**
 * 事件编辑器组件
 */
interface EventEditorProps {
  events: EventMap;
  definitions: EventDefinition[];
  onChange: (events: EventMap) => void;
  componentId: string;
}

function EventEditor({ events, definitions, onChange, componentId }: EventEditorProps) {
  // 处理事件更新
  const handleEventChange = (eventName: string, config: any) => {
    const updatedEvents = {
      ...events,
      [eventName]: config
    };
    
    onChange(updatedEvents);
  };
  
  // 处理事件删除
  const handleEventDelete = (eventName: string) => {
    const updatedEvents = { ...events };
    delete updatedEvents[eventName];
    
    onChange(updatedEvents);
  };
  
  return (
    <div className="event-editor">
      <div className="event-editor-header">
        <h3>事件处理</h3>
      </div>
      
      <div className="event-editor-content">
        {definitions.map(eventDef => {
          const eventConfig = events[eventDef.name];
          
          return (
            <div key={eventDef.name} className="event-item">
              <div className="event-item-header">
                <div className="event-name">{eventDef.label}</div>
                {eventConfig ? (
                  <Button 
                    size="small" 
                    danger 
                    onClick={() => handleEventDelete(eventDef.name)}
                  >
                    删除
                  </Button>
                ) : (
                  <Button 
                    size="small" 
                    type="primary" 
                    onClick={() => handleEventChange(eventDef.name, {
                      type: 'function',
                      handler: '',
                      params: {}
                    })}
                  >
                    添加
                  </Button>
                )}
              </div>
              
              {eventConfig && (
                <div className="event-config">
                  <div className="event-type">
                    <Select
                      value={eventConfig.type}
                      onChange={(value) => handleEventChange(eventDef.name, {
                        ...eventConfig,
                        type: value
                      })}
                      options={[
                        { label: '函数', value: 'function' },
                        { label: '导航', value: 'navigation' },
                        { label: '状态变更', value: 'state' },
                        { label: 'API调用', value: 'api' },
                      ]}
                    />
                  </div>
                  
                  {/* 根据事件类型渲染不同的配置 */}
                  {eventConfig.type === 'function' && (
                    <FunctionEventConfig
                      config={eventConfig}
                      onChange={(config) => handleEventChange(eventDef.name, config)}
                      componentId={componentId}
                    />
                  )}
                  
                  {eventConfig.type === 'navigation' && (
                    <NavigationEventConfig
                      config={eventConfig}
                      onChange={(config) => handleEventChange(eventDef.name, config)}
                    />
                  )}
                  
                  {eventConfig.type === 'state' && (
                    <StateEventConfig
                      config={eventConfig}
                      onChange={(config) => handleEventChange(eventDef.name, config)}
                    />
                  )}
                  
                  {eventConfig.type === 'api' && (
                    <ApiEventConfig
                      config={eventConfig}
                      onChange={(config) => handleEventChange(eventDef.name, config)}
                    />
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

#### 3.3.3 数据绑定编辑器

```tsx
/**
 * 数据绑定编辑器组件
 */
interface DataBindingEditorProps {
  bindings: DataBindings;
  onChange: (bindings: DataBindings) => void;
  availableDataSources: DataSource[];
}

function DataBindingEditor({ bindings, onChange, availableDataSources }: DataBindingEditorProps) {
  // 添加数据绑定
  const addBinding = (propPath: string) => {
    onChange({
      ...bindings,
      [propPath]: {
        type: 'state',
        source: '',
      }
    });
  };
  
  // 更新数据绑定
  const updateBinding = (propPath: string, binding: any) => {
    onChange({
      ...bindings,
      [propPath]: binding
    });
  };
  
  // 删除数据绑定
  const removeBinding = (propPath: string) => {
    const updatedBindings = { ...bindings };
    delete updatedBindings[propPath];
    
    onChange(updatedBindings);
  };
  
  return (
    <div className="data-binding-editor">
      <div className="data-binding-editor-header">
        <h3>数据绑定</h3>
        <Button type="primary" onClick={() => addBinding('')}>添加绑定</Button>
      </div>
      
      <div className="data-binding-editor-content">
        {Object.entries(bindings).map(([propPath, binding]) => (
          <div key={propPath} className="binding-item">
            <div className="binding-prop-path">
              <Input
                value={propPath}
                onChange={(e) => {
                  const newPropPath = e.target.value;
                  const bindingValue = bindings[propPath];
                  
                  // 删除旧路径的绑定
                  const updatedBindings = { ...bindings };
                  delete updatedBindings[propPath];
                  
                  // 添加到新路径
                  onChange({
                    ...updatedBindings,
                    [newPropPath]: bindingValue
                  });
                }}
                placeholder="属性路径"
              />
            </div>
            
            <div className="binding-type">
              <Select
                value={binding.type}
                onChange={(value) => updateBinding(propPath, {
                  ...binding,
                  type: value
                })}
                options={[
                  { label: '状态', value: 'state' },
                  { label: 'API', value: 'api' },
                  { label: '计算属性', value: 'computed' },
                  { label: '上下文', value: 'context' },
                ]}
              />
            </div>
            
            <div className="binding-source">
              {binding.type === 'state' && (
                <StateSourceSelector
                  value={binding.source}
                  onChange={(source) => updateBinding(propPath, {
                    ...binding,
                    source
                  })}
                  availableStates={availableDataSources.filter(ds => ds.type === 'state')}
                />
              )}
              
              {binding.type === 'api' && (
                <ApiSourceSelector
                  value={binding.source}
                  onChange={(source) => updateBinding(propPath, {
                    ...binding,
                    source
                  })}
                  availableApis={availableDataSources.filter(ds => ds.type === 'api')}
                />
              )}
              
              {binding.type === 'computed' && (
                <ExpressionEditor
                  value={binding.source}
                  onChange={(source) => updateBinding(propPath, {
                    ...binding,
                    source
                  })}
                />
              )}
              
              {binding.type === 'context' && (
                <ContextSourceSelector
                  value={binding.source}
                  onChange={(source) => updateBinding(propPath, {
                    ...binding,
                    source
                  })}
                  availableContexts={availableDataSources.filter(ds => ds.type === 'context')}
                />
              )}
            </div>
            
            <div className="binding-transform">
              <Input
                value={binding.transform}
                onChange={(e) => updateBinding(propPath, {
                  ...binding,
                  transform: e.target.value
                })}
                placeholder="转换表达式"
              />
            </div>
            
            <div className="binding-actions">
              <Button 
                danger 
                icon={<DeleteIcon />} 
                onClick={() => removeBinding(propPath)}
              />
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 3.4 属性面板优化

为了提供更好的用户体验，我们对属性面板进行了以下优化：

#### 3.4.1 性能优化

```typescript
// 属性面板性能优化

// 1. 使用虚拟滚动处理大量属性
const VirtualizedPropertyList = ({ properties, component, onChange }) => {
  return (
    <VirtualList
      height={600}
      itemCount={properties.length}
      itemSize={50}
      width="100%"
      itemData={{
        properties,
        component,
        onChange
      }}
    >
      {({ index, style, data }) => {
        const { properties, component, onChange } = data;
        const propDef = properties[index];
        
        return (
          <div style={style}>
            <PropertyEditor
              key={propDef.name}
              definition={propDef}
              value={component.props[propDef.name]}
              onChange={(value) => onChange(propDef.name, value)}
            />
          </div>
        );
      }}
    </VirtualList>
  );
};

// 2. 属性变更节流
const useThrottledChange = (onChange, delay = 300) => {
  const throttledChange = useThrottle(onChange, delay);
  
  return throttledChange;
};

// 3. 缓存常用计算结果
const usePropGroups = (propDefinitions) => {
  return useMemo(() => {
    return groupPropsByCategory(propDefinitions);
  }, [propDefinitions]);
};
```

#### 3.4.2 用户体验优化

```typescript
// 属性面板用户体验优化

// 1. 上下文相关属性展示
const useContextualProperties = (component, propDefinitions) => {
  return useMemo(() => {
    // 基于组件当前状态筛选相关属性
    return propDefinitions.filter(propDef => {
      // 检查条件属性
      if (propDef.condition) {
        return evaluateCondition(propDef.condition, component.props);
      }
      
      return true;
    });
  }, [component, propDefinitions]);
};

// 2. 智能排序 - 将常用属性排在前面
const useSmartSortedProps = (properties, component) => {
  return useMemo(() => {
    // 基于用户编辑频率排序
    const editFrequency = getPropertyEditFrequency(component.type);
    
    return [...properties].sort((a, b) => {
      const freqA = editFrequency[a.name] || 0;
      const freqB = editFrequency[b.name] || 0;
      
      return freqB - freqA;
    });
  }, [properties, component.type]);
};

// 3. 历史记录与最近使用
const RecentPropertiesSection = ({ component, onChange }) => {
  const recentProps = useRecentProperties(component.type);
  
  return (
    <div className="recent-properties">
      <h3>最近编辑</h3>
      <div className="recent-properties-list">
        {recentProps.map(propName => {
          const propDef = findPropDefinition(component.type, propName);
          if (!propDef) return null;
          
          return (
            <PropertyEditor
              key={propName}
              definition={propDef}
              value={component.props[propName]}
              onChange={(value) => onChange(propName, value)}
            />
          );
        })}
      </div>
    </div>
  );
};
```

## 4. 组件交互系统

组件交互系统定义了组件之间的交互方式，包括事件传递、数据流和状态共享。

### 4.1 组件通信模型

低代码编辑器中的组件通信模型包括以下几种方式：

1. **直接属性传递**：父组件通过属性直接传递数据给子组件
2. **事件机制**：子组件通过触发事件通知父组件或其他组件
3. **数据绑定**：组件与外部数据源（如状态、API等）建立绑定关系
4. **上下文共享**：通过上下文机制在组件树中共享数据
5. **全局状态**：通过全局状态管理组件间的通信

### 4.2 事件处理系统

```typescript
// 事件处理系统

// 事件处理器映射
interface EventHandlerMap {
  [componentId: string]: {
    [eventName: string]: EventHandler;
  };
}

// 事件处理器
interface EventHandler {
  type: 'function' | 'navigation' | 'state' | 'api';
  handler: string;
  params?: Record<string, any>;
}

// 事件处理服务
class EventHandlerService {
  private eventHandlers: EventHandlerMap = {};
  
  // 注册事件处理器
  registerEventHandler(
    componentId: string,
    eventName: string,
    handler: EventHandler
  ): void {
    if (!this.eventHandlers[componentId]) {
      this.eventHandlers[componentId] = {};
    }
    
    this.eventHandlers[componentId][eventName] = handler;
  }
  
  // 获取事件处理器
  getEventHandler(
    componentId: string,
    eventName: string
  ): EventHandler | undefined {
    return this.eventHandlers[componentId]?.[eventName];
  }
  
  // 触发事件
  triggerEvent(
    componentId: string,
    eventName: string,
    eventData?: any
  ): void {
    const handler = this.getEventHandler(componentId, eventName);
    
    if (!handler) return;
    
    // 执行事件处理器
    this.executeHandler(handler, eventData);
  }
  
  // 执行处理器
  private executeHandler(handler: EventHandler, eventData?: any): void {
    switch (handler.type) {
      case 'function':
        this.executeFunctionHandler(handler, eventData);
        break;
      case 'navigation':
        this.executeNavigationHandler(handler);
        break;
      case 'state':
        this.executeStateHandler(handler, eventData);
        break;
      case 'api':
        this.executeApiHandler(handler, eventData);
        break;
      default:
        console.warn(`Unknown handler type: ${handler.type}`);
    }
  }
  
  // 执行函数处理器
  private executeFunctionHandler(handler: EventHandler, eventData?: any): void {
    try {
      // 解析函数字符串
      const func = new Function('data', 'params', handler.handler);
      
      // 执行函数
      func(eventData, handler.params);
    } catch (error) {
      console.error('Error executing function handler:', error);
    }
  }
  
  // 执行导航处理器
  private executeNavigationHandler(handler: EventHandler): void {
    const { url, target, params } = handler.params || {};
    
    if (!url) return;
    
    // 构建URL
    const urlWithParams = buildUrlWithParams(url, params);
    
    // 执行导航
    if (target === '_blank') {
      window.open(urlWithParams, '_blank');
    } else {
      window.location.href = urlWithParams;
    }
  }
  
  // 执行状态处理器
  private executeStateHandler(handler: EventHandler, eventData?: any): void {
    const { stateName, action, value } = handler.params || {};
    
    if (!stateName || !action) return;
    
    // 获取状态管理服务
    const stateService = getStateService();
    
    // 执行状态操作
    switch (action) {
      case 'set':
        stateService.setState(stateName, value);
        break;
      case 'update':
        const currentState = stateService.getState(stateName);
        const newValue = typeof value === 'function'
          ? value(currentState, eventData)
          : { ...currentState, ...value };
        stateService.setState(stateName, newValue);
        break;
      case 'toggle':
        const boolState = stateService.getState(stateName);
        stateService.setState(stateName, !boolState);
        break;
      case 'reset':
        stateService.resetState(stateName);
        break;
      default:
        console.warn(`Unknown state action: ${action}`);
    }
  }
  
  // 执行API处理器
  private executeApiHandler(handler: EventHandler, eventData?: any): void {
    const { api, params, onSuccess, onError } = handler.params || {};
    
    if (!api) return;
    
    // 获取API服务
    const apiService = getApiService();
    
    // 执行API调用
    apiService.callApi(api, params, eventData)
      .then(result => {
        if (onSuccess) {
          // 执行成功回调
          this.executeHandler(onSuccess, result);
        }
      })
      .catch(error => {
        if (onError) {
          // 执行错误回调
          this.executeHandler(onError, error);
        }
      });
  }
}
```

## 5. 组件物料系统分层架构

为了更好地满足不同层次的开发需求，我们将组件物料系统分为多个层次：

### 5.1 物料分层设计

```
+---------------------+
|   自定义业务组件     |   ← 业务开发者定制
+---------------------+
|   领域组件          |   ← 领域专家/行业模板
+---------------------+
|   高级复合组件      |   ← 中级开发者
+---------------------+
|   基础组件库        |   ← 初级用户
+---------------------+
|   系统原子组件      |   ← 平台内置
+---------------------+
```

1. **系统原子组件**：平台内置的最基本组件，如文本、图像、按钮等
2. **基础组件库**：基于原子组件封装的常用UI组件，如卡片、表单项等
3. **高级复合组件**：组合多个基础组件形成的功能组件，如搜索栏、注册表单等
4. **领域组件**：特定行业或领域的专用组件，如电商商品卡、医疗数据图表等
5. **自定义业务组件**：用户自行创建的满足特定业务需求的组件

### 5.2 物料注册机制

```typescript
/**
 * 物料层级
 */
enum MaterialLevel {
  ATOMIC = 'atomic',           // 原子组件
  BASIC = 'basic',             // 基础组件
  COMPOSITE = 'composite',     // 复合组件
  DOMAIN = 'domain',           // 领域组件
  CUSTOM = 'custom',           // 自定义组件
}

/**
 * 物料来源
 */
enum MaterialSource {
  SYSTEM = 'system',           // 系统内置
  OFFICIAL = 'official',       // 官方提供
  MARKETPLACE = 'marketplace', // 市场组件
  USER = 'user',               // 用户创建
}

/**
 * 扩展的组件定义
 */
interface EnhancedComponentDefinition extends ComponentDefinition {
  level: MaterialLevel;        // 组件层级
  source: MaterialSource;      // 组件来源
  version: string;             // 组件版本
  author?: string;             // 作者
  dependencies?: string[];     // 依赖的其他组件
  tags?: string[];             // 标签
  searchable: boolean;         // 是否可搜索
  hidden: boolean;             // 是否在组件面板中隐藏
}

/**
 * 分层物料注册表
 */
class LayeredMaterialRegistry extends ComponentRegistry {
  // 按层级分类的组件
  private componentsByLevel: Record<MaterialLevel, Map<string, EnhancedComponentDefinition>> = {
    [MaterialLevel.ATOMIC]: new Map(),
    [MaterialLevel.BASIC]: new Map(),
    [MaterialLevel.COMPOSITE]: new Map(),
    [MaterialLevel.DOMAIN]: new Map(),
    [MaterialLevel.CUSTOM]: new Map(),
  };
  
  // 按来源分类的组件
  private componentsBySource: Record<MaterialSource, Map<string, EnhancedComponentDefinition>> = {
    [MaterialSource.SYSTEM]: new Map(),
    [MaterialSource.OFFICIAL]: new Map(),
    [MaterialSource.MARKETPLACE]: new Map(),
    [MaterialSource.USER]: new Map(),
  };
  
  /**
   * 注册增强组件
   */
  registerEnhanced(definition: EnhancedComponentDefinition): void {
    // 调用父类方法注册基本信息
    super.register(definition);
    
    // 按层级分类
    this.componentsByLevel[definition.level].set(definition.type, definition);
    
    // 按来源分类
    this.componentsBySource[definition.source].set(definition.type, definition);
  }
  
  /**
   * 按层级获取组件
   */
  getByLevel(level: MaterialLevel): EnhancedComponentDefinition[] {
    return Array.from(this.componentsByLevel[level].values());
  }
  
  /**
   * 按来源获取组件
   */
  getBySource(source: MaterialSource): EnhancedComponentDefinition[] {
    return Array.from(this.componentsBySource[source].values());
  }
  
  /**
   * 按标签查询组件
   */
  getByTag(tag: string): EnhancedComponentDefinition[] {
    return this.getAllDefinitions().filter(
      def => (def as EnhancedComponentDefinition).tags?.includes(tag)
    ) as EnhancedComponentDefinition[];
  }
  
  /**
   * 搜索组件
   */
  search(query: string): EnhancedComponentDefinition[] {
    const lowercaseQuery = query.toLowerCase();
    
    return this.getAllDefinitions().filter(def => {
      const enhancedDef = def as EnhancedComponentDefinition;
      
      // 只搜索可搜索的组件
      if (!enhancedDef.searchable) return false;
      
      // 匹配名称、类型、描述、标签
      return (
        def.name.toLowerCase().includes(lowercaseQuery) ||
        def.type.toLowerCase().includes(lowercaseQuery) ||
        def.category.toLowerCase().includes(lowercaseQuery) ||
        enhancedDef.tags?.some(tag => tag.toLowerCase().includes(lowercaseQuery))
      );
    }) as EnhancedComponentDefinition[];
  }
}
```

### 5.3 物料扩展系统

```typescript
/**
 * 物料包定义
 */
interface MaterialPackage {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  components: EnhancedComponentDefinition[];
  dependencies: Record<string, string>; // 依赖包及版本
  assets: string[]; // 资源文件
}

/**
 * 物料包管理器
 */
class MaterialPackageManager {
  private packages: Map<string, MaterialPackage> = new Map();
  private registry: LayeredMaterialRegistry;
  
  constructor(registry: LayeredMaterialRegistry) {
    this.registry = registry;
  }
  
  /**
   * 安装物料包
   */
  async installPackage(packageId: string, version?: string): Promise<boolean> {
    try {
      // 获取包信息
      const packageInfo = await this.fetchPackageInfo(packageId, version);
      
      // 检查依赖
      await this.checkAndInstallDependencies(packageInfo);
      
      // 加载包资源
      await this.loadPackageAssets(packageInfo);
      
      // 注册组件
      for (const component of packageInfo.components) {
        this.registry.registerEnhanced(component);
      }
      
      // 存储包信息
      this.packages.set(packageId, packageInfo);
      
      return true;
    } catch (error) {
      console.error(`Failed to install package ${packageId}:`, error);
      return false;
    }
  }
  
  /**
   * 卸载物料包
   */
  uninstallPackage(packageId: string): boolean {
    const pkg = this.packages.get(packageId);
    if (!pkg) return false;
    
    // 从注册表中移除组件
    pkg.components.forEach(comp => {
      this.registry.unregister(comp.type);
    });
    
    // 移除包信息
    this.packages.delete(packageId);
    
    return true;
  }
  
  // 其他辅助方法...
}
```

## 6. 组件级虚拟化

为了提高大量组件场景下的渲染性能，我们实现了组件级虚拟化技术：

### 6.1 虚拟化渲染器

```typescript
/**
 * 虚拟化渲染配置
 */
interface VirtualizationConfig {
  enabled: boolean;
  overscan: number;       // 视口外预渲染的项数
  minItemHeight: number;  // 最小项高度估算
  scrollingDelay: number; // 滚动防抖延迟
  recycleDOM: boolean;    // 是否回收DOM元素
  lazyRender: boolean;    // 懒加载渲染
}

/**
 * 组件虚拟化管理器
 */
class ComponentVirtualizer {
  private config: VirtualizationConfig = {
    enabled: true,
    overscan: 5,
    minItemHeight: 50,
    scrollingDelay: 100,
    recycleDOM: true,
    lazyRender: true
  };
  
  // 视口信息
  private viewport: {
    width: number;
    height: number;
    scrollTop: number;
    scrollLeft: number;
  } = { width: 0, height: 0, scrollTop: 0, scrollLeft: 0 };
  
  // 组件位置缓存
  private componentRects: Map<string, { top: number; height: number }> = new Map();
  
  // 滚动处理防抖
  private scrollTimer: number | null = null;
  
  constructor(config?: Partial<VirtualizationConfig>) {
    if (config) {
      this.config = { ...this.config, ...config };
    }
  }
  
  /**
   * 设置视口信息
   */
  setViewport(viewport: typeof this.viewport): void {
    this.viewport = viewport;
  }
  
  /**
   * 更新组件位置信息
   */
  updateComponentRect(componentId: string, rect: { top: number; height: number }): void {
    this.componentRects.set(componentId, rect);
  }
  
  /**
   * 处理滚动事件
   */
  handleScroll(scrollTop: number, scrollLeft: number, callback: () => void): void {
    this.viewport.scrollTop = scrollTop;
    this.viewport.scrollLeft = scrollLeft;
    
    // 防抖处理
    if (this.scrollTimer !== null) {
      window.clearTimeout(this.scrollTimer);
    }
    
    this.scrollTimer = window.setTimeout(() => {
      callback();
      this.scrollTimer = null;
    }, this.config.scrollingDelay);
  }
  
  /**
   * 计算可见组件
   */
  getVisibleComponents(components: ComponentSchema[]): ComponentSchema[] {
    if (!this.config.enabled) {
      return components;
    }
    
    const { scrollTop, height, width } = this.viewport;
    const visibleTop = scrollTop;
    const visibleBottom = scrollTop + height;
    const overscan = this.config.overscan;
    
    // 扩展可见范围
    const extendedTop = Math.max(0, visibleTop - overscan * this.config.minItemHeight);
    const extendedBottom = visibleBottom + overscan * this.config.minItemHeight;
    
    // 过滤可见组件
    return components.filter(component => {
      const rect = this.componentRects.get(component.id);
      
      // 如果没有位置信息，默认可见
      if (!rect) return true;
      
      const { top, height } = rect;
      const bottom = top + height;
      
      // 检查是否在扩展可见范围内
      return (bottom >= extendedTop && top <= extendedBottom);
    });
  }
}
```

### 6.2 虚拟化组件渲染器

```tsx
/**
 * 虚拟化画布渲染器组件
 */
function VirtualizedCanvas({ 
  components, 
  canvasHeight, 
  canvasWidth, 
  overscan = 5 
}: {
  components: ComponentSchema[];
  canvasHeight: number;
  canvasWidth: number;
  overscan?: number;
}) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollPosition, setScrollPosition] = useState({ top: 0, left: 0 });
  const [viewportDimensions, setViewportDimensions] = useState({ width: 0, height: 0 });
  
  // 创建虚拟化管理器
  const virtualizer = useMemo(() => new ComponentVirtualizer({
    overscan,
    enabled: components.length > 20 // 只在组件数量超过阈值时启用
  }), [components.length, overscan]);
  
  // 更新视口信息
  useEffect(() => {
    if (containerRef.current) {
      const { clientWidth, clientHeight } = containerRef.current;
      setViewportDimensions({ width: clientWidth, height: clientHeight });
      virtualizer.setViewport({
        width: clientWidth,
        height: clientHeight,
        scrollTop: scrollPosition.top,
        scrollLeft: scrollPosition.left
      });
    }
  }, [containerRef.current, scrollPosition, virtualizer]);
  
  // 处理滚动事件
  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {
    const { scrollTop, scrollLeft } = event.currentTarget;
    setScrollPosition({ top: scrollTop, left: scrollLeft });
    
    virtualizer.handleScroll(scrollTop, scrollLeft, () => {
      // 触发重新渲染
      forceUpdate();
    });
  }, [virtualizer]);
  
  // 获取可见组件
  const visibleComponents = useMemo(() => 
    virtualizer.getVisibleComponents(components), 
    [virtualizer, components, scrollPosition]
  );
  
  // 测量并更新组件位置
  const measureComponent = useCallback((id: string, element: HTMLElement | null) => {
    if (element) {
      const rect = element.getBoundingClientRect();
      const containerRect = containerRef.current?.getBoundingClientRect();
      
      if (containerRect) {
        virtualizer.updateComponentRect(id, {
          top: rect.top - containerRect.top + scrollPosition.top,
          height: rect.height
        });
      }
    }
  }, [virtualizer, scrollPosition]);
  
  return (
    <div 
      ref={containerRef}
      className="virtualized-canvas-container"
      style={{ 
        width: '100%', 
        height: '100%', 
        overflow: 'auto',
        position: 'relative'
      }}
      onScroll={handleScroll}
    >
      <div 
        className="canvas-content"
        style={{ 
          height: canvasHeight, 
          width: canvasWidth,
          position: 'relative'
        }}
      >
        {/* 仅渲染可见组件 */}
        {visibleComponents.map(component => (
          <div 
            key={component.id}
            ref={el => measureComponent(component.id, el)}
            style={{ 
              position: 'absolute', 
              left: component.style?.left as number || 0, 
              top: component.style?.top as number || 0
            }}
          >
            <ComponentRenderer component={component} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 7.3 DOM 回收机制

为了进一步优化性能，我们实现了组件 DOM 回收机制：

```typescript
/**
 * DOM 回收池
 */
class DOMRecycler {
  // 按组件类型存储的元素池
  private pools: Record<string, HTMLElement[]> = {};
  // 最大池大小
  private maxPoolSize: number = 50;
  
  /**
   * 从池中获取元素
   */
  acquire(componentType: string): HTMLElement | null {
    const pool = this.pools[componentType];
    if (!pool || pool.length === 0) {
      return null;
    }
    
    return pool.pop() || null;
  }
  
  /**
   * 返回元素到池中
   */
  release(componentType: string, element: HTMLElement): void {
    if (!this.pools[componentType]) {
      this.pools[componentType] = [];
    }
    
    const pool = this.pools[componentType];
    
    // 清理元素状态
    this.cleanElement(element);
    
    // 检查池大小
    if (pool.length < this.maxPoolSize) {
      pool.push(element);
    }
  }
  
  /**
   * 清理元素状态
   */
  private cleanElement(element: HTMLElement): void {
    // 移除事件监听器
    const clone = element.cloneNode(false) as HTMLElement;
    clone.innerHTML = '';
    
    // 保留原始属性
    Array.from(element.attributes).forEach(attr => {
      if (attr.name !== 'style' && !attr.name.startsWith('data-')) {
        clone.setAttribute(attr.name, attr.value);
      }
    });
    
    return clone;
  }
  
  /**
   * 清空池
   */
  clear(componentType?: string): void {
    if (componentType) {
      delete this.pools[componentType];
    } else {
      this.pools = {};
    }
  }
}

/**
 * 使用DOM回收的组件渲染器
 */
function RecyclableComponentRenderer({ component, recycler }: { 
  component: ComponentSchema, 
  recycler: DOMRecycler 
}) {
  const elementRef = useRef<HTMLElement | null>(null);
  
  // 组件卸载时回收DOM
  useEffect(() => {
    return () => {
      if (elementRef.current) {
        recycler.release(component.type, elementRef.current);
      }
    };
  }, [component.type, recycler]);
  
  // 组件挂载时尝试获取回收的DOM
  useLayoutEffect(() => {
    const recycled = recycler.acquire(component.type);
    if (recycled && elementRef.current?.parentNode) {
      elementRef.current.parentNode.replaceChild(recycled, elementRef.current);
      elementRef.current = recycled;
    }
  }, [component.type, recycler]);
  
  // 渲染组件
  return (
    <div ref={elementRef as React.RefObject<HTMLDivElement>}>
      <ComponentRenderer component={component} />
    </div>
  );
}
```

这些高级优化技术使我们的编辑器能够流畅处理大量组件，提供丝滑的交互体验。 


## 下一步

继续阅读[代码生成与预览](./06-代码生成与预览.md)了解代码生成与预览。