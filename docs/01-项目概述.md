# 项目概述

## 1. 项目背景与目标

### 背景

随着数字化转型的加速，企业对快速开发和迭代Web应用的需求日益增长。传统开发模式周期长、成本高，难以满足业务快速变化的需求。低代码平台作为解决方案，使非专业开发人员也能快速创建应用，但现有低代码平台往往存在以下问题：

- 学习曲线陡峭，不够直观
- 生成的代码质量低，难以维护
- 扩展性差，定制化能力有限
- 编辑与预览体验割裂，缺乏所见即所得的感觉
- 缺乏AI辅助能力，无法充分利用大模型潜力

### 项目目标

我们的AI低代码编辑器（AI-LowCode-Editor）旨在创建一个下一代低代码开发平台，具备以下目标：

1. **极致用户体验**：提供真正所见即所得的编辑体验，消除编辑-预览-发布之间的割裂感
2. **高质量代码输出**：生成符合最佳实践的、可维护的代码
3. **AI驱动设计**：集成AI能力，辅助布局、生成组件、优化代码
4. **专业级扩展性**：支持高度自定义，满足专业开发者需求
5. **高性能与响应式**：支持复杂页面编辑且保持流畅体验
6. **无缝集成与发布**：简化从设计到上线的全流程

## 2. 核心功能

### 编辑器核心

- **无iframe画布系统**：统一渲染引擎实现真正所见即所得
- **自定义拖拽系统**：高性能、精确的组件拖放与布局
- **智能网格与辅助线**：精确对齐与布局辅助
- **多级撤销/重做**：完整的历史记录管理
- **响应式设计工具**：支持各种设备预览与适配

### 组件系统

- **丰富组件库**：包含UI、布局、表单、数据等多类组件
- **组件嵌套**：支持复杂组件层级结构
- **自定义组件**：支持用户创建与共享自定义组件
- **组件模板**：预设常用组件组合与布局

### 属性编辑

- **直观属性面板**：上下文相关的属性编辑
- **内联编辑**：直接在画布上编辑文本与属性
- **样式控制**：可视化样式编辑器
- **事件处理**：可视化事件配置与流程设计

### 代码生成与预览

- **统一渲染引擎**：编辑-预览-发布三模式无缝切换
- **高质量代码生成**：生成可读、优化的代码
- **多框架支持**：支持React、Vue等多种框架
- **一键发布**：支持多种部署目标与方式

### AI增强功能

- **自然语言创建**：通过描述生成组件与布局
- **智能布局建议**：AI辅助优化页面结构
- **代码智能修复**：自动识别并修复代码问题
- **性能优化建议**：提供性能改进方案

## 3. 技术选型分析

### 基础框架

| 选项 | 决策 | 理由 |
|------|------|------|
| **Next.js 15** | ✅ 选用 | App Router架构、最新React特性支持、良好SEO |
| **React 19** | ✅ 选用 | 最新特性支持、并发渲染、React Server Components |
| **TypeScript** | ✅ 选用 | 类型安全、开发体验提升、代码可维护性 |

### 状态管理

| 选项 | 决策 | 理由 |
|------|------|------|
| **Zustand** | ✅ 选用 | 轻量级、易用性高、良好TypeScript支持、中间件支持 |
| **Signals** | ❌ 不选 | 虽支持细粒度更新，但生态不成熟，与复杂编辑器状态集成难度高 |
| **Redux** | ❌ 不选 | 过于冗长的样板代码，对编辑器高频状态更新不够高效 |
| **Context API** | ❌ 不选 | 性能问题，不适合频繁更新的编辑器状态 |

### 拖拽实现

| 选项 | 决策 | 理由 |
|------|------|------|
| **自定义实现** | ✅ 选用 | 完全控制、针对低代码场景优化、支持特殊交互需求 |
| **react-dnd** | ❌ 不选 | 维护减少，API复杂，不够灵活，性能问题 |
| **@dnd-kit/core** | ❌ 不选 | 虽然现代化，但仍难以满足低代码编辑器特殊需求 |

### 预览实现

| 选项 | 决策 | 理由 |
|------|------|------|
| **统一渲染引擎** | ✅ 选用 | 无感切换、所见即所得、无额外编译开销 |
| **iframe** | ❌ 不选 | 割裂体验、通信开销、状态同步复杂 |

### 代码生成

| 选项 | 决策 | 理由 |
|------|------|------|
| **AST转换** | ✅ 选用 | 代码质量高、灵活性强、支持多框架 |
| **模板替换** | ❌ 不选 | 灵活性差，难以生成复杂代码结构 |
| **双模式架构** | ✅ 选用 | 结合静态生成和动态渲染优点，兼顾性能与灵活性 |

### UI组件库

| 选项 | 决策 | 理由 |
|------|------|------|
| **Shadcn/UI** | ✅ 选用 | 高质量组件、基于Tailwind、源码可控 |
| **Radix UI** | ✅ 选用 | 作为底层可访问性组件，与Shadcn配合 |
| **MUI** | ❌ 不选 | 体积大、样式定制复杂、过度抽象 |

### 工具库

| 选项 | 决策 | 理由 |
|------|------|------|
| **Immer** | ✅ 选用 | 简化不可变状态更新，配合Zustand使用 |
| **Zod** | ✅ 选用 | 运行时类型验证，确保数据一致性 |
| **Nanoid** | ✅ 选用 | 轻量级唯一ID生成，组件标识使用 |

## 4. 主要技术挑战与解决方案

| 挑战 | 解决方案 |
|------|----------|
| 高性能大型页面编辑 | 虚拟滚动、组件懒加载、选择性渲染 |
| 精确拖拽与定位 | 自定义拖拽引擎、网格系统、智能参考线 |
| 复杂组件嵌套与交互 | 层级选择器、面包屑导航、上下文菜单 |
| 无感切换编辑/预览 | 统一渲染引擎、CSS模式隔离、交互层 |
| 高质量代码生成 | AST优化、代码格式化、模块化输出 |
| AI集成与优化 | 流式生成、本地小模型+云端大模型混合架构 |

## 5. 创新点

1. **统一渲染引擎**：突破传统iframe预览限制，实现真正所见即所得
2. **自定义拖拽系统**：针对低代码场景优化的高性能拖拽实现
3. **AI辅助设计**：将AI能力深度集成到设计流程
4. **双模式架构**：结合代码生成与运行时渲染的优点
5. **组件自学习**：根据用户行为优化组件推荐与布局建议

## 下一步

继续阅读[架构设计](./02-架构设计.md)了解系统的整体架构与核心模块设计。 