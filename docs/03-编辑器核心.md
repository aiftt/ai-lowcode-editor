# 编辑器核心

## 1. 自定义拖拽实现

### 1.1 设计原则

我们选择自行实现拖拽系统而非使用现有库，基于以下考虑：

1. **专用性**：为低代码编辑场景定制，支持特殊交互需求
2. **性能**：针对频繁拖拽操作优化性能
3. **灵活性**：完全控制拖拽行为和视觉反馈
4. **扩展性**：便于集成网格对齐、智能辅助线等特性

### 1.2 拖拽系统架构

```
+-------------------+      +-------------------+
|                   |      |                   |
|    拖拽服务        +<---->+    放置服务       |
|  DragService      |      |  DropService      |
|                   |      |                   |
+--------+----------+      +---------+---------+
         ^                           ^
         |                           |
         v                           v
+--------+----------+      +---------+---------+
|                   |      |                   |
|    拖拽源组件      |      |    放置目标组件    |
|  DragSource       |      |  DropTarget       |
|                   |      |                   |
+-------------------+      +-------------------+
         ^                           ^
         |                           |
         v                           v
+--------+----------+      +---------+---------+
|                   |      |                   |
|    拖拽预览        |      |    定位系统       |
|  DragPreview      |      |  PositioningSystem|
|                   |      |                   |
+-------------------+      +-------------------+
```

### 1.3 核心实现

#### DragDropService

```typescript
// 拖拽服务核心
class DragDropService {
  private isDragging: boolean = false;
  private draggedElement: HTMLElement | null = null;
  private draggedComponentType: string | null = null;
  private initialPosition: { x: number; y: number } = { x: 0, y: 0 };
  private dropZones: Map<string, HTMLElement> = new Map();
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    this.init();
  }
  
  init() {
    // 全局事件监听
    document.addEventListener('pointerup', this.handlePointerUp.bind(this));
    document.addEventListener('pointermove', this.handlePointerMove.bind(this));
  }
  
  // 开始拖拽
  startDrag(element: HTMLElement, componentType: string, event: PointerEvent) {
    this.isDragging = true;
    this.draggedElement = element;
    this.draggedComponentType = componentType;
    this.initialPosition = { x: event.clientX, y: event.clientY };
    
    // 通知拖拽开始
    this.eventBus.publish('drag:start', {
      componentType,
      position: this.initialPosition
    });
    
    // 创建拖拽预览
    this.createDragPreview();
    
    // 标记所有可放置区域
    this.highlightDropZones();
  }
  
  // 注册放置区域
  registerDropZone(element: HTMLElement, zoneId: string) {
    this.dropZones.set(zoneId, element);
    
    // 返回清理函数
    return () => {
      this.dropZones.delete(zoneId);
    };
  }
  
  // 处理拖拽移动
  private handlePointerMove(event: PointerEvent) {
    if (!this.isDragging) return;
    
    // 更新拖拽预览位置
    this.updateDragPreviewPosition(event.clientX, event.clientY);
    
    // 检测悬停在哪个放置区域
    const hoveredZone = this.findHoveredDropZone(event.clientX, event.clientY);
    
    // 通知悬停状态变化
    this.eventBus.publish('drag:hover', {
      zoneId: hoveredZone?.id,
      position: { x: event.clientX, y: event.clientY }
    });
  }
  
  // 处理拖拽释放
  private handlePointerUp(event: PointerEvent) {
    if (!this.isDragging) return;
    
    // 查找当前位置的放置区域
    const dropZone = this.findHoveredDropZone(event.clientX, event.clientY);
    
    if (dropZone) {
      // 计算精确放置位置
      const dropPosition = this.calculateDropPosition(dropZone.element, event);
      
      // 通知放置事件
      this.eventBus.publish('drag:drop', {
        componentType: this.draggedComponentType,
        zoneId: dropZone.id,
        position: dropPosition
      });
    }
    
    // 清理拖拽状态
    this.cleanupDragState();
    
    // 通知拖拽结束
    this.eventBus.publish('drag:end', {});
  }
  
  // 其他辅助方法...
}
```

#### useDragDrop Hook

```typescript
// 拖拽Hook
function useDragDrop() {
  const dragDropService = useContext(DragDropContext);
  
  // 开始拖拽
  const startDrag = useCallback((element: HTMLElement, componentType: string, event: React.PointerEvent) => {
    dragDropService.startDrag(element, componentType, event.nativeEvent);
  }, [dragDropService]);
  
  // 注册放置区域
  const registerDropZone = useCallback((element: HTMLElement, zoneId: string) => {
    return dragDropService.registerDropZone(element, zoneId);
  }, [dragDropService]);
  
  // 监听拖拽事件
  const onDragEvent = useCallback((eventType: string, handler: (data: any) => void) => {
    return dragDropService.eventBus.subscribe(`drag:${eventType}`, handler);
  }, [dragDropService]);
  
  return {
    startDrag,
    registerDropZone,
    onDragEvent
  };
}
```

### 1.4 拖拽组件

#### DragSource

```tsx
interface DragSourceProps {
  componentType: string;
  children: React.ReactNode;
  preview?: React.ReactNode;
  disabled?: boolean;
}

function DragSource({ componentType, children, preview, disabled }: DragSourceProps) {
  const { startDrag } = useDragDrop();
  const elementRef = useRef<HTMLDivElement>(null);
  
  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (disabled || !elementRef.current) return;
    
    // 阻止默认行为
    e.preventDefault();
    
    // 开始拖拽
    startDrag(elementRef.current, componentType, e);
  }, [startDrag, componentType, disabled]);
  
  return (
    <div 
      ref={elementRef}
      className={`drag-source ${disabled ? 'drag-disabled' : ''}`}
      onPointerDown={handlePointerDown}
      data-component-type={componentType}
    >
      {children}
    </div>
  );
}
```

#### DropTarget

```tsx
interface DropTargetProps {
  zoneId: string;
  children: React.ReactNode;
  onDrop?: (data: DropData) => void;
  disabled?: boolean;
  className?: string;
}

function DropTarget({ zoneId, children, onDrop, disabled, className }: DropTargetProps) {
  const { registerDropZone, onDragEvent } = useDragDrop();
  const elementRef = useRef<HTMLDivElement>(null);
  const [isHovered, setIsHovered] = useState(false);
  
  // 注册放置区域
  useEffect(() => {
    if (elementRef.current && !disabled) {
      return registerDropZone(elementRef.current, zoneId);
    }
  }, [registerDropZone, zoneId, disabled]);
  
  // 监听放置事件
  useEffect(() => {
    if (disabled || !onDrop) return;
    
    const unsubscribe = onDragEvent('drop', (data: DropData) => {
      if (data.zoneId === zoneId) {
        onDrop(data);
      }
    });
    
    return unsubscribe;
  }, [onDragEvent, onDrop, zoneId, disabled]);
  
  // 监听悬停事件
  useEffect(() => {
    if (disabled) return;
    
    const unsubscribe = onDragEvent('hover', (data: any) => {
      setIsHovered(data.zoneId === zoneId);
    });
    
    return unsubscribe;
  }, [onDragEvent, zoneId, disabled]);
  
  return (
    <div 
      ref={elementRef}
      className={`drop-target ${isHovered ? 'drop-target-hovered' : ''} ${className || ''}`}
      data-zone-id={zoneId}
    >
      {children}
    </div>
  );
}
```

### 1.5 定位系统

定位系统支持多种布局模式，包括绝对定位、网格布局和流式布局。

```typescript
// 定位系统
class PositioningSystem {
  // 布局模式
  private layoutMode: 'absolute' | 'grid' | 'flow' = 'absolute';
  // 网格尺寸
  private gridSize: number = 8;
  // 是否启用网格吸附
  private snapToGrid: boolean = true;
  
  // 计算放置位置
  calculateDropPosition(
    dropZone: HTMLElement, 
    event: PointerEvent, 
    draggedType: string
  ): DropPosition {
    switch (this.layoutMode) {
      case 'absolute':
        return this.calculateAbsolutePosition(dropZone, event);
      case 'grid':
        return this.calculateGridPosition(dropZone, event);
      case 'flow':
        return this.calculateFlowPosition(dropZone, event, draggedType);
      default:
        return this.calculateAbsolutePosition(dropZone, event);
    }
  }
  
  // 计算绝对定位位置
  private calculateAbsolutePosition(dropZone: HTMLElement, event: PointerEvent): DropPosition {
    const rect = dropZone.getBoundingClientRect();
    let x = event.clientX - rect.left;
    let y = event.clientY - rect.top;
    
    // 应用网格吸附
    if (this.snapToGrid) {
      x = Math.round(x / this.gridSize) * this.gridSize;
      y = Math.round(y / this.gridSize) * this.gridSize;
    }
    
    return {
      type: 'absolute',
      x,
      y
    };
  }
  
  // 其他定位计算方法...
}
```

## 2. 画布系统

画布系统是用户构建页面的核心区域，提供组件放置、选择和编辑功能。

### 2.1 画布架构

```
+-------------------+
|    画布容器        |
|  CanvasContainer  |
+-------------------+
          |
          v
+-------------------+      +-------------------+
|     画布背景       |      |     网格系统      |
|  CanvasBackground |      |    GridSystem    |
+-------------------+      +-------------------+
          |                         |
          v                         v
+-------------------+      +-------------------+
|    组件渲染器      |      |     交互层        |
| ComponentRenderer |      | InteractionLayer |
+-------------------+      +-------------------+
          |                         |
          v                         v
+-------------------+      +-------------------+
|   选择管理器       |      |     辅助线        |
| SelectionManager  |      |   GuidesSystem   |
+-------------------+      +-------------------+
```

### 2.2 画布组件实现

#### Canvas

```tsx
interface CanvasProps {
  zoom: number;
  showGrid: boolean;
  snapToGrid: boolean;
  width: number;
  height: number;
  mode: 'edit' | 'preview' | 'publish';
}

function Canvas({ 
  zoom, 
  showGrid, 
  snapToGrid, 
  width, 
  height, 
  mode 
}: CanvasProps) {
  const { componentTree } = useEditorStore();
  const { registerDropZone } = useDragDrop();
  const canvasRef = useRef<HTMLDivElement>(null);
  
  // 注册画布为放置区域
  useEffect(() => {
    if (canvasRef.current && mode === 'edit') {
      return registerDropZone(canvasRef.current, 'canvas-root');
    }
  }, [registerDropZone, mode]);
  
  // 处理组件放置
  const handleDrop = useCallback((data: DropData) => {
    if (data.zoneId === 'canvas-root') {
      // 添加新组件到状态
      editorActions.addComponent({
        type: data.componentType,
        position: data.position,
        props: {},
        style: {}
      });
    }
  }, []);
  
  return (
    <div className="canvas-container" style={{ width, height }}>
      {/* 画布背景 */}
      <CanvasBackground 
        showGrid={showGrid} 
        gridSize={8} 
        zoom={zoom} 
      />
      
      {/* 画布内容区 */}
      <div 
        ref={canvasRef}
        className={`canvas-content mode-${mode}`}
        style={{ 
          transform: `scale(${zoom})`,
          transformOrigin: '0 0',
        }}
        onDrop={mode === 'edit' ? handleDrop : undefined}
      >
        {/* 渲染组件树 */}
        {componentTree.map(component => (
          <ComponentRenderer 
            key={component.id}
            component={component}
            mode={mode}
          />
        ))}
      </div>
      
      {/* 编辑模式交互层 */}
      {mode === 'edit' && (
        <InteractionLayer 
          zoom={zoom} 
          snapToGrid={snapToGrid} 
        />
      )}
    </div>
  );
}
```

#### ComponentRenderer

```tsx
interface ComponentRendererProps {
  component: ComponentSchema;
  mode: 'edit' | 'preview' | 'publish';
}

function ComponentRenderer({ component, mode }: ComponentRendererProps) {
  const { selectedComponentId } = useEditorStore();
  const isSelected = selectedComponentId === component.id;
  
  // 获取组件实现
  const Component = useComponentImplementation(component.type);
  
  // 没有找到组件实现时显示占位符
  if (!Component) {
    return <UnknownComponentPlaceholder type={component.type} />;
  }
  
  // 处理选择事件
  const handleSelect = (e: React.MouseEvent) => {
    if (mode !== 'edit') return;
    
    e.stopPropagation();
    editorActions.selectComponent(component.id);
  };
  
  return (
    <div 
      className={`component-wrapper ${isSelected ? 'selected' : ''} mode-${mode}`}
      data-component-id={component.id}
      onClick={handleSelect}
      style={component.style}
    >
      {/* 编辑模式下显示组件控件 */}
      {mode === 'edit' && isSelected && (
        <ComponentControls component={component} />
      )}
      
      {/* 渲染实际组件 */}
      <Component {...component.props}>
        {/* 递归渲染子组件 */}
        {component.children?.map(child => (
          <ComponentRenderer 
            key={child.id} 
            component={child} 
            mode={mode} 
          />
        ))}
      </Component>
    </div>
  );
}
```

### 2.3 交互层

交互层负责处理编辑模式下的用户交互，如选择、调整大小等。

```tsx
interface InteractionLayerProps {
  zoom: number;
  snapToGrid: boolean;
}

function InteractionLayer({ zoom, snapToGrid }: InteractionLayerProps) {
  const { selectedComponentId, hoveredComponentId } = useEditorStore();
  
  // 绘制选择框
  const renderSelectionBox = useCallback(() => {
    if (!selectedComponentId) return null;
    
    return <SelectionBox componentId={selectedComponentId} zoom={zoom} />;
  }, [selectedComponentId, zoom]);
  
  // 绘制悬停指示器
  const renderHoverIndicator = useCallback(() => {
    if (!hoveredComponentId || hoveredComponentId === selectedComponentId) return null;
    
    return <HoverIndicator componentId={hoveredComponentId} zoom={zoom} />;
  }, [hoveredComponentId, selectedComponentId, zoom]);
  
  // 绘制辅助线
  const renderGuides = useCallback(() => {
    if (!selectedComponentId || !snapToGrid) return null;
    
    return <GuidesSystem componentId={selectedComponentId} zoom={zoom} />;
  }, [selectedComponentId, snapToGrid, zoom]);
  
  return (
    <div className="interaction-layer">
      {renderHoverIndicator()}
      {renderSelectionBox()}
      {renderGuides()}
    </div>
  );
}
```

## 3. 组件模型

组件模型定义了低代码编辑器中组件的数据结构和行为。

### 3.1 组件Schema

```typescript
// 组件Schema
interface ComponentSchema {
  // 基本信息
  id: string;                  // 组件唯一ID
  type: string;                // 组件类型
  
  // 数据与样式
  props: Record<string, any>;  // 组件属性
  style: CSSProperties;        // 样式属性
  
  // 结构信息
  children?: ComponentSchema[]; // 子组件
  parentId?: string;           // 父组件ID
  
  // 交互信息
  events?: EventMap;           // 事件映射
  
  // 元信息
  meta?: {
    label: string;             // 显示名称
    icon?: string;             // 组件图标
    category: string;          // 分类
    description?: string;      // 描述
  };
  
  // 验证与绑定
  rules?: ValidationRules;     // 验证规则
  dataBindings?: DataBindings; // 数据绑定
}

// 事件映射
interface EventMap {
  [eventName: string]: {
    type: 'function' | 'navigation' | 'state' | 'api';
    handler: string;
    params?: Record<string, any>;
  };
}

// 数据绑定
interface DataBindings {
  [propPath: string]: {
    type: 'state' | 'api' | 'computed';
    source: string;
    transform?: string;
  };
}
```

### 3.2 组件模型类

```typescript
// 组件模型
class ComponentModel {
  schema: ComponentSchema;
  
  constructor(schema: ComponentSchema) {
    this.schema = schema;
  }
  
  // 克隆组件
  clone(): ComponentModel {
    return new ComponentModel(structuredClone(this.schema));
  }
  
  // 更新属性
  updateProps(props: Record<string, any>): this {
    this.schema.props = { ...this.schema.props, ...props };
    return this;
  }
  
  // 更新样式
  updateStyle(style: CSSProperties): this {
    this.schema.style = { ...this.schema.style, ...style };
    return this;
  }
  
  // 添加子组件
  addChild(child: ComponentSchema): this {
    if (!this.schema.children) {
      this.schema.children = [];
    }
    
    child.parentId = this.schema.id;
    this.schema.children.push(child);
    return this;
  }
  
  // 移除子组件
  removeChild(childId: string): this {
    if (!this.schema.children) return this;
    
    this.schema.children = this.schema.children.filter(
      child => child.id !== childId
    );
    
    return this;
  }
  
  // 检查是否可以包含子组件
  canHaveChildren(): boolean {
    const containerTypes = ['div', 'section', 'container', 'form', 'card'];
    return containerTypes.includes(this.schema.type);
  }
  
  // 检查是否可以接受特定类型的子组件
  canAcceptChild(childType: string): boolean {
    // 特殊规则示例：表单只能包含表单项
    if (this.schema.type === 'form') {
      const formItemTypes = ['input', 'select', 'checkbox', 'radio', 'textarea'];
      return formItemTypes.includes(childType);
    }
    
    // 默认规则
    return this.canHaveChildren();
  }
  
  // 其他辅助方法...
}
```

### 3.3 组件注册表

```typescript
// 组件定义
interface ComponentDefinition {
  type: string;
  name: string;
  category: string;
  icon?: string;
  defaultProps?: Record<string, any>;
  defaultStyle?: CSSProperties;
  propDefinitions: PropDefinition[];
  component: React.ComponentType<any>;
  allowChildren?: boolean;
  childrenTypes?: string[];
  maxChildren?: number;
  isContainer?: boolean;
}

// 组件注册表
class ComponentRegistry {
  private components: Map<string, ComponentDefinition> = new Map();
  
  // 注册组件
  register(definition: ComponentDefinition): void {
    if (this.components.has(definition.type)) {
      throw new Error(`组件类型 "${definition.type}" 已经注册`);
    }
    
    this.components.set(definition.type, definition);
  }
  
  // 获取组件定义
  getDefinition(type: string): ComponentDefinition | undefined {
    return this.components.get(type);
  }
  
  // 获取所有组件定义
  getAllDefinitions(): ComponentDefinition[] {
    return Array.from(this.components.values());
  }
  
  // 按分类获取组件
  getByCategory(category: string): ComponentDefinition[] {
    return this.getAllDefinitions().filter(
      def => def.category === category
    );
  }
  
  // 创建组件实例
  createInstance(type: string): ComponentSchema | null {
    const definition = this.getDefinition(type);
    
    if (!definition) return null;
    
    return {
      id: nanoid(),
      type: definition.type,
      props: definition.defaultProps || {},
      style: definition.defaultStyle || {},
      children: definition.isContainer ? [] : undefined,
      meta: {
        label: definition.name,
        icon: definition.icon,
        category: definition.category
      }
    };
  }
}
```

### 3.4 组件工厂

```typescript
// 组件工厂
class ComponentFactory {
  private registry: ComponentRegistry;
  
  constructor(registry: ComponentRegistry) {
    this.registry = registry;
  }
  
  // 创建组件
  createComponent(type: string, props?: Record<string, any>, style?: CSSProperties): ComponentSchema | null {
    const baseComponent = this.registry.createInstance(type);
    
    if (!baseComponent) return null;
    
    // 合并传入的属性和样式
    if (props) {
      baseComponent.props = { ...baseComponent.props, ...props };
    }
    
    if (style) {
      baseComponent.style = { ...baseComponent.style, ...style };
    }
    
    return baseComponent;
  }
  
  // 创建组件树
  createComponentTree(config: ComponentTreeConfig): ComponentSchema[] {
    return config.map(item => this.createComponentTreeNode(item));
  }
  
  // 创建组件树节点
  private createComponentTreeNode(config: ComponentNodeConfig): ComponentSchema {
    const { type, props, style, children } = config;
    
    const component = this.createComponent(type, props, style);
    
    if (!component) {
      throw new Error(`无法创建类型为 "${type}" 的组件`);
    }
    
    // 处理子组件
    if (children && children.length > 0) {
      component.children = children.map(
        childConfig => this.createComponentTreeNode(childConfig)
      );
      
      // 设置父子关系
      component.children.forEach(child => {
        child.parentId = component.id;
      });
    }
    
    return component;
  }
}
```

## 下一步

继续阅读[状态管理](./04-状态管理.md)了解编辑器的状态管理设计。 