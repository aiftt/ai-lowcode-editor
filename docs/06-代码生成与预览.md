# 代码生成与预览

## 1. 无iframe预览实现

### 1.1 统一渲染引擎

我们采用统一渲染引擎实现真正的所见即所得，避免使用iframe带来的割裂体验。

```typescript
/**
 * 统一渲染引擎核心类
 */
class UnifiedRenderer {
  // 渲染组件树
  render(
    componentTree: ComponentSchema[], 
    container: HTMLElement,
    mode: 'edit' | 'preview' | 'publish'
  ) {
    // 清空容器
    container.innerHTML = '';
    
    // 设置渲染模式
    container.setAttribute('data-render-mode', mode);
    
    // 处理根级组件
    componentTree.forEach(component => {
      const element = this.renderComponent(component, mode);
      container.appendChild(element);
    });
    
    // 根据模式应用不同行为
    this.applyModeSpecificBehavior(container, mode);
  }
  
  // 渲染单个组件
  private renderComponent(
    component: ComponentSchema, 
    mode: 'edit' | 'preview' | 'publish'
  ): HTMLElement {
    // 创建DOM元素
    const element = document.createElement(component.tagName || 'div');
    
    // 应用属性
    this.applyAttributes(element, component.props);
    
    // 应用样式
    this.applyStyles(element, component.style);
    
    // 应用事件（只在预览和发布模式）
    if (mode !== 'edit') {
      this.attachEvents(element, component.events);
    }
    
    // 添加编辑模式专用属性
    if (mode === 'edit') {
      element.setAttribute('data-component-id', component.id);
      element.classList.add('editor-component');
    }
    
    // 递归渲染子组件
    if (component.children && component.children.length > 0) {
      component.children.forEach(child => {
        const childElement = this.renderComponent(child, mode);
        element.appendChild(childElement);
      });
    } else if (component.content) {
      // 处理文本内容
      element.textContent = component.content;
    }
    
    return element;
  }
}
```

### 1.2 模式切换机制

```typescript
// 模式管理器
class ModeManager {
  private currentMode: 'edit' | 'preview' | 'publish' = 'edit';
  private container: HTMLElement;
  private renderer: UnifiedRenderer;
  private componentTree: ComponentSchema[];
  
  constructor(container: HTMLElement) {
    this.container = container;
    this.renderer = new UnifiedRenderer();
  }
  
  // 切换模式
  switchMode(mode: 'edit' | 'preview' | 'publish') {
    if (this.currentMode === mode) return;
    
    // 保存当前滚动位置
    const scrollPosition = {
      top: this.container.scrollTop,
      left: this.container.scrollLeft
    };
    
    // 更新模式
    this.currentMode = mode;
    
    // 重新渲染
    this.renderer.render(this.componentTree, this.container, mode);
    
    // 恢复滚动位置
    this.container.scrollTop = scrollPosition.top;
    this.container.scrollLeft = scrollPosition.left;
  }
}
```

### 1.3 CSS隔离与交互层

```typescript
// CSS隔离实现
private applyScopedStyles(component: ComponentSchema) {
  // 为每个组件创建唯一的作用域
  const scopeId = `component-${component.id}`;
  
  // 创建作用域样式
  const styles = document.createElement('style');
  
  // 转换所有样式规则为作用域规则
  const scopedCss = this.transformToCssScopedRules(component.styles, scopeId);
  styles.textContent = scopedCss;
  
  // 应用作用域ID
  component.element.setAttribute('data-scope-id', scopeId);
  
  // 添加样式到文档
  document.head.appendChild(styles);
}

// 交互层管理
class InteractionLayerManager {
  private container: HTMLElement;
  private overlayLayer: HTMLElement;
  
  constructor(container: HTMLElement) {
    this.container = container;
    this.createOverlayLayer();
  }
  
  // 创建覆盖交互层
  private createOverlayLayer() {
    this.overlayLayer = document.createElement('div');
    this.overlayLayer.className = 'editor-interaction-layer';
    
    // 定位在容器之上
    this.overlayLayer.style.position = 'absolute';
    this.overlayLayer.style.top = '0';
    this.overlayLayer.style.left = '0';
    this.overlayLayer.style.width = '100%';
    this.overlayLayer.style.height = '100%';
    this.overlayLayer.style.pointerEvents = 'none'; // 默认不拦截事件
    
    this.container.appendChild(this.overlayLayer);
  }
  
  // 切换模式
  setMode(mode: 'edit' | 'preview' | 'publish') {
    if (mode === 'edit') {
      // 在编辑模式下显示
      this.overlayLayer.style.display = 'block';
    } else {
      // 在其他模式下隐藏
      this.overlayLayer.style.display = 'none';
    }
  }
}
```

## 2. 代码生成策略

### 2.1 代码生成架构

```
ComponentSchema -> 中间AST -> 目标代码
```

### 2.2 代码生成服务

```typescript
/**
 * 代码生成服务
 */
class CodeGenerationService {
  // 生成代码
  generateCode(
    componentTree: ComponentSchema[], 
    options: CodeGenOptions
  ): GeneratedCode {
    // 预处理组件树
    const processedTree = this.preprocessTree(componentTree);
    
    // 转换为AST
    const ast = this.generateAST(processedTree, options);
    
    // 生成框架代码
    switch (options.framework) {
      case 'react':
        return this.generateReactCode(ast, options);
      case 'vue':
        return this.generateVueCode(ast, options);
      case 'angular':
        return this.generateAngularCode(ast, options);
      case 'html':
        return this.generateHtmlCode(ast, options);
      default:
        return this.generateReactCode(ast, options);
    }
  }
  
  // 生成React代码
  private generateReactCode(
    ast: ComponentAST, 
    options: CodeGenOptions
  ): GeneratedCode {
    // 生成组件代码
    const componentsCode = this.generateReactComponents(ast);
    
    // 生成页面代码
    const pageCode = this.generateReactPage(ast, componentsCode);
    
    // 生成样式代码
    const stylesCode = this.generateReactStyles(ast);
    
    // 生成依赖项
    const dependencies = this.generateReactDependencies(ast);
    
    return {
      components: componentsCode,
      page: pageCode,
      styles: stylesCode,
      dependencies
    };
  }
}
```

### 2.3 多框架支持

```typescript
// 支持多框架代码生成的工厂
class CodeGeneratorFactory {
  // 获取特定框架的代码生成器
  static getGenerator(framework: string): CodeGenerator {
    switch (framework) {
      case 'react':
        return new ReactCodeGenerator();
      case 'vue':
        return new VueCodeGenerator();
      case 'angular':
        return new AngularCodeGenerator();
      case 'html':
        return new HtmlCodeGenerator();
      default:
        return new ReactCodeGenerator();
    }
  }
}

// React代码生成器
class ReactCodeGenerator implements CodeGenerator {
  // 生成组件
  generateComponent(component: ComponentSchema): string {
    const { type, props, children } = component;
    
    // 处理属性
    const propsStr = this.generateProps(props);
    
    // 处理子组件
    const childrenStr = this.generateChildren(children);
    
    // 生成组件代码
    return `<${type} ${propsStr}>${childrenStr}</${type}>`;
  }
  
  // 生成页面
  generatePage(components: ComponentSchema[]): string {
    return `
import React from 'react';
import './styles.css';

export default function Page() {
  return (
    <div className="page">
      ${components.map(comp => this.generateComponent(comp)).join('\n      ')}
    </div>
  );
}
`;
  }
}
```

### 2.4 代码优化

```typescript
// 代码优化器
class CodeOptimizer {
  // 去重复代码
  deduplicate(code: string): string {
    // 识别重复的代码片段
    const patterns = this.findRepeatingPatterns(code);
    
    // 提取为函数或组件
    return this.extractPatterns(code, patterns);
  }
  
  // 优化引入
  optimizeImports(code: string): string {
    // 分析使用的组件和库
    const imports = this.analyzeImports(code);
    
    // 去除未使用的引入
    return this.removeUnusedImports(code, imports);
  }
  
  // 优化样式
  optimizeStyles(styles: string): string {
    // 合并相似样式
    const mergedStyles = this.mergeStyles(styles);
    
    // 删除未使用的样式
    return this.removeUnusedStyles(mergedStyles);
  }
}
```

## 3. 发布流程

### 3.1 发布准备

```typescript
// 发布服务
class PublishService {
  // 准备发布
  prepareForPublish(componentTree: ComponentSchema[]): PublishBundle {
    // 清理编辑器特定数据
    const cleanedTree = this.cleanupEditorData(componentTree);
    
    // 优化组件树
    const optimizedTree = this.optimizeComponentTree(cleanedTree);
    
    // 生成发布资源
    return {
      schema: optimizedTree,
      assets: this.extractAssets(optimizedTree),
      meta: this.generateMetadata(optimizedTree)
    };
  }
  
  // 生成发布代码
  generatePublishCode(bundle: PublishBundle): PublishableCode {
    // 生成HTML
    const html = this.generateHTML(bundle);
    
    // 生成CSS
    const css = this.generateCSS(bundle);
    
    // 生成JS
    const js = this.generateJS(bundle);
    
    // 打包依赖
    const dependencies = this.bundleDependencies(bundle);
    
    return { html, css, js, dependencies };
  }
}
```

### 3.2 部署选项

```typescript
// 部署服务
class DeploymentService {
  // 静态文件部署
  async deployStaticFiles(
    publishableCode: PublishableCode, 
    options: StaticDeployOptions
  ): Promise<DeployResult> {
    // 生成静态文件
    const files = this.generateStaticFiles(publishableCode);
    
    // 上传到指定位置
    return this.uploadFiles(files, options.destination);
  }
  
  // 服务器部署
  async deployToServer(
    publishableCode: PublishableCode,
    options: ServerDeployOptions
  ): Promise<DeployResult> {
    // 生成部署包
    const deployPackage = this.generateDeployPackage(publishableCode);
    
    // 上传到服务器
    return this.uploadToServer(deployPackage, options);
  }
  
  // 云服务部署
  async deployToCloud(
    publishableCode: PublishableCode,
    options: CloudDeployOptions
  ): Promise<DeployResult> {
    // 准备云部署资源
    const cloudResources = this.prepareCloudResources(publishableCode);
    
    // 部署到云服务
    return this.deployToCloudProvider(cloudResources, options);
  }
}
```

### 3.3 版本管理

```typescript
// 版本管理服务
class VersionManagementService {
  // 创建版本
  createVersion(project: Project): Version {
    return {
      id: generateUUID(),
      projectId: project.id,
      timestamp: Date.now(),
      schema: structuredClone(project.schema),
      label: `版本 ${project.versions.length + 1}`,
      createdBy: getCurrentUser().id
    };
  }
  
  // 恢复版本
  restoreVersion(project: Project, versionId: string): Project {
    // 查找版本
    const version = project.versions.find(v => v.id === versionId);
    
    if (!version) {
      throw new Error(`版本不存在: ${versionId}`);
    }
    
    // 创建新的当前版本
    const currentVersion = this.createVersion(project);
    
    // 恢复到旧版本
    return {
      ...project,
      schema: structuredClone(version.schema),
      versions: [...project.versions, currentVersion]
    };
  }
}
```

## 4. 优化策略

### 4.1 性能优化

- **代码分割**：将生成的代码分割为多个小块，提高加载性能
- **懒加载**：动态加载组件，减少初始加载时间
- **资源优化**：压缩图片和其他资源，减少网络传输
- **样式优化**：使用CSS-in-JS或CSS Modules避免样式冲突

### 4.2 用户体验优化

- **渐进式加载**：优先加载关键内容，逐步显示其他内容
- **预加载**：预测用户行为，提前加载可能需要的资源
- **离线支持**：使用Service Worker提供离线访问能力
- **动画过渡**：添加适当的过渡动画，提升用户体验

### 4.3 SEO优化

- **语义化标签**：使用正确的HTML语义标签
- **元数据生成**：自动生成合适的元数据标签
- **结构化数据**：添加结构化数据，提高搜索引擎理解能力
- **响应式设计**：确保在所有设备上正确显示

## 5. 前沿特性

### 5.1 Web Components支持

```typescript
// Web Components生成器
class WebComponentsGenerator {
  // 将组件树转换为Web Components
  generateWebComponents(componentTree: ComponentSchema[]): string {
    return componentTree.map(component => {
      return this.generateWebComponent(component);
    }).join('\n\n');
  }
  
  // 生成单个Web Component
  private generateWebComponent(component: ComponentSchema): string {
    const className = pascalCase(component.type) + 'Component';
    
    return `
class ${className} extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  render() {
    ${this.generateRenderMethod(component)}
  }
}

customElements.define('${kebabCase(component.type)}', ${className});
`;
  }
}
```

### 5.2 双模式架构

```typescript
// 双模式渲染器
class DualModeRenderer {
  // 设计时渲染
  renderDesignTime(schema: ComponentSchema, container: HTMLElement) {
    // 使用统一渲染引擎直接渲染
    const renderer = new UnifiedRenderer();
    renderer.render([schema], container, 'edit');
  }
  
  // 运行时渲染
  renderRunTime(schema: ComponentSchema, container: HTMLElement) {
    // 选择合适的渲染策略
    if (this.shouldUseInterpretation(schema)) {
      // 解释执行
      this.interpretSchema(schema, container);
    } else {
      // 编译执行
      this.compileAndRender(schema, container);
    }
  }
  
  // 解释执行Schema
  private interpretSchema(schema: ComponentSchema, container: HTMLElement) {
    const schemaInterpreter = new SchemaInterpreter();
    schemaInterpreter.interpret(schema, container);
  }
  
  // 编译并渲染
  private compileAndRender(schema: ComponentSchema, container: HTMLElement) {
    // 编译为优化的函数
    const renderFn = this.compileSchema(schema);
    
    // 执行渲染函数
    renderFn(container);
  }
}
```

## 下一步

继续阅读[AI增强功能](./07-AI增强功能.md)了解如何集成AI能力到低代码编辑器中。 