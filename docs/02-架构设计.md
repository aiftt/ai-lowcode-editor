# 架构设计

## 1. 整体架构

AI低代码编辑器采用模块化、分层架构设计，确保系统的可扩展性和可维护性。

### 系统架构图

```
+-------------------------------------------+
|                  UI层                     |
|   +-------------+  +------------------+   |
|   |  编辑器界面  |  |    预览/发布界面  |   |
|   +-------------+  +------------------+   |
+-------------------------------------------+
                     |
+-------------------------------------------+
|                 核心层                     |
|   +-------------+  +------------------+   |
|   |  编辑器引擎  |  |    渲染引擎       |   |
|   +-------------+  +------------------+   |
|   +-------------+  +------------------+   |
|   |  组件系统   |  |    状态管理       |   |
|   +-------------+  +------------------+   |
+-------------------------------------------+
                     |
+-------------------------------------------+
|                 服务层                     |
|   +-------------+  +------------------+   |
|   |  拖拽服务   |  |    代码生成服务   |   |
|   +-------------+  +------------------+   |
|   +-------------+  +------------------+   |
|   |  历史服务   |  |    AI服务        |   |
|   +-------------+  +------------------+   |
+-------------------------------------------+
                     |
+-------------------------------------------+
|                 数据层                     |
|   +-------------+  +------------------+   |
|   |  组件模型   |  |    页面模型       |   |
|   +-------------+  +------------------+   |
|   +-------------+  +------------------+   |
|   |  项目存储   |  |    用户配置       |   |
|   +-------------+  +------------------+   |
+-------------------------------------------+
```

### 核心架构理念

1. **分离关注点**：UI层、核心层、服务层和数据层职责明确分离
2. **模块化设计**：每个功能都是独立模块，可单独维护和替换
3. **插件化扩展**：支持通过插件机制扩展各层功能
4. **统一状态管理**：集中管理应用状态，保证数据一致性
5. **统一渲染引擎**：编辑、预览、发布共用渲染核心，确保一致性

### 技术架构

```
+----------------------------------------------+
|              Next.js 15 应用                 |
+----------------------------------------------+
                      |
+-----------------+   |   +--------------------+
|   React 19 组件  |<--+-->|  Zustand 状态管理  |
+-----------------+       +--------------------+
        |                           |
+-------------------+      +-------------------+
|  自定义拖拽系统    |      |  统一渲染引擎     |
+-------------------+      +-------------------+
        |                           |
+-------------------+      +-------------------+
|  Shadcn/UI 组件   |      |   代码生成系统    |
+-------------------+      +-------------------+
        |                           |
+-------------------+      +-------------------+
|  TailwindCSS 样式 |      |    AI 服务集成    |
+-------------------+      +-------------------+
```

## 2. 核心模块设计

### 2.1 编辑器引擎 (EditorEngine)

编辑器引擎是整个系统的核心，负责协调各个模块的工作。

**主要职责**：
- 初始化编辑器环境
- 管理编辑器生命周期
- 协调各个服务之间的交互
- 提供插件注册与管理机制

**关键组件**：
- **EditorContext**：提供全局上下文
- **PluginManager**：管理插件注册与生命周期
- **ServiceRegistry**：注册和管理各种服务
- **EventBus**：编辑器内事件通信总线

### 2.2 渲染引擎 (RenderEngine)

渲染引擎负责将组件树渲染为可视化界面，支持多种渲染模式。

**主要职责**：
- 将组件模型转换为DOM元素
- 处理组件的样式与交互
- 支持编辑/预览/发布三种模式
- 确保渲染结果一致性

**关键组件**：
- **UnifiedRenderer**：统一渲染核心
- **ComponentRenderer**：组件渲染器
- **StyleProcessor**：样式处理器
- **ModeManager**：模式管理器
- **InteractionLayer**：交互层管理

### 2.3 拖拽系统 (DragDropSystem)

自定义实现的拖拽系统，专为低代码编辑场景优化。

**主要职责**：
- 处理组件从面板到画布的拖拽
- 处理画布内组件的移动与定位
- 支持组件嵌套与组合
- 提供拖拽过程中的视觉反馈

**关键组件**：
- **DragDropService**：拖拽核心服务
- **DragSource**：拖拽源
- **DropTarget**：放置目标
- **DragPreview**：拖拽预览
- **PositioningSystem**：定位系统

### 2.4 组件系统 (ComponentSystem)

管理所有可用的组件及其元数据。

**主要职责**：
- 组件注册与分类
- 组件实例创建与管理
- 组件属性定义与校验
- 组件间通信与交互

**关键组件**：
- **ComponentRegistry**：组件注册中心
- **ComponentFactory**：组件工厂
- **ComponentMetadata**：组件元数据
- **ComponentValidator**：组件校验器

### 2.5 状态管理 (StateManagement)

基于Zustand的状态管理系统，管理编辑器的全局状态。

**主要职责**：
- 管理组件树状态
- 管理选中组件状态
- 管理历史记录
- 管理编辑器配置

**关键组件**：
- **EditorStore**：编辑器核心状态
- **ComponentStore**：组件状态
- **HistoryStore**：历史记录状态
- **SelectionStore**：选择状态

### 2.6 代码生成系统 (CodeGeneration)

负责将组件树转换为可执行的代码。

**主要职责**：
- 将组件树转换为AST
- 生成各种框架的代码
- 优化生成的代码
- 处理代码依赖

**关键组件**：
- **CodeGenerator**：代码生成器
- **ASTTransformer**：AST转换器
- **CodeOptimizer**：代码优化器
- **DependencyManager**：依赖管理器

### 2.7 AI服务 (AIService)

集成AI能力，提供智能辅助功能。

**主要职责**：
- 处理自然语言指令
- 提供布局建议
- 生成组件代码
- 优化现有代码

**关键组件**：
- **AIConnector**：AI服务连接器
- **LayoutSuggester**：布局建议器
- **CodeGenerator**：代码生成器
- **UIOptimizer**：界面优化器

## 3. 数据流设计

### 3.1 单向数据流

AI低代码编辑器采用单向数据流架构，确保数据流动的可预测性和调试的便捷性。

```
+----------------+      +----------------+      +----------------+
|                |      |                |      |                |
|  状态 (State)  +----->+  视图 (View)   +----->+  操作 (Action) |
|                |      |                |      |                |
+----------------+      +----------------+      +-------+--------+
       ^                                                |
       |                                                |
       +------------------------------------------------+
```

1. **状态**：由Zustand管理的中央状态
2. **视图**：React组件渲染的UI
3. **操作**：用户交互触发的动作，最终更新状态

### 3.2 状态变更流程

```
用户操作 ---> Action触发 ---> 中间件处理 ---> 状态更新 ---> UI重渲染
   ^                                                          |
   |                                                          |
   +----------------------------------------------------------+
```

每个状态变更遵循以下流程：
1. 用户执行操作（如拖拽组件）
2. 操作触发相应Action
3. Action经过中间件处理（如记录历史）
4. 更新Zustand状态
5. React组件响应状态变化并重新渲染

### 3.3 主要数据模型

#### 组件模型 (ComponentModel)

```typescript
interface ComponentSchema {
  id: string;                  // 组件唯一ID
  type: string;                // 组件类型
  props: Record<string, any>;  // 组件属性
  style: CSSProperties;        // 样式属性
  children?: ComponentSchema[]; // 子组件
  parentId?: string;           // 父组件ID
  events?: EventMap;           // 事件映射
  meta?: {                     // 元数据
    label: string;             // 显示名称
    icon?: string;             // 组件图标
    category: string;          // 分类
    description?: string;      // 描述
  };
  rules?: ValidationRules;     // 验证规则
  dataBindings?: DataBindings; // 数据绑定
}
```

#### 页面模型 (PageModel)

```typescript
interface PageSchema {
  id: string;                  // 页面ID
  name: string;                // 页面名称
  components: ComponentSchema[]; // 根组件列表
  styles?: GlobalStyles;       // 全局样式
  settings?: PageSettings;     // 页面设置
  meta?: PageMetadata;         // 页面元数据
}
```

#### 编辑器状态 (EditorState)

```typescript
interface EditorState {
  // 组件树
  componentTree: ComponentSchema[];
  
  // 选择状态
  selection: {
    selectedComponentId: string | null;
    hoveredComponentId: string | null;
    multiSelection: string[];
  };
  
  // 画布设置
  canvas: {
    zoom: number;
    showGrid: boolean;
    snapToGrid: boolean;
    gridSize: number;
    width: number;
    height: number;
    deviceMode: 'desktop' | 'tablet' | 'mobile';
  };
  
  // 历史记录
  history: {
    past: EditorSnapshot[];
    future: EditorSnapshot[];
    currentIndex: number;
  };
  
  // 编辑器模式
  mode: 'edit' | 'preview' | 'publish';
  
  // 其他状态...
}
```

### 3.4 状态切片设计

为了更好地管理复杂状态，将编辑器状态分为多个切片：

1. **componentSlice**：管理组件树
2. **selectionSlice**：管理选择状态
3. **canvasSlice**：管理画布设置
4. **historySlice**：管理历史记录
5. **modeSlice**：管理编辑器模式

```typescript
// 状态切片示例
const useComponentSlice = create<ComponentSlice>()(
  immer((set) => ({
    componentTree: [],
    
    addComponent: (component, parentId) => set((state) => {
      if (!parentId) {
        state.componentTree.push(component);
      } else {
        addComponentToParent(state.componentTree, parentId, component);
      }
    }),
    
    updateComponent: (id, updates) => set((state) => {
      updateComponentById(state.componentTree, id, updates);
    }),
    
    // 其他操作...
  }))
);
```

### 3.5 事件系统

编辑器使用事件总线实现松耦合的模块间通信：

```typescript
// 事件总线
class EventBus {
  private listeners: Record<string, Function[]> = {};
  
  // 订阅事件
  subscribe(event: string, callback: Function): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    
    this.listeners[event].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
    };
  }
  
  // 发布事件
  publish(event: string, data?: any): void {
    if (!this.listeners[event]) return;
    
    this.listeners[event].forEach(callback => {
      callback(data);
    });
  }
}
```

### 3.6 数据持久化

编辑器支持多种数据持久化方式：

1. **本地存储**：使用IndexedDB存储项目数据
2. **云端存储**：支持将项目保存到云端
3. **导出/导入**：支持将项目导出为JSON或导入现有项目
4. **版本控制**：支持项目版本历史记录

## 4. 扩展机制

### 4.1 插件系统

编辑器支持通过插件扩展功能：

```typescript
// 插件接口
interface EditorPlugin {
  id: string;
  name: string;
  version: string;
  init: (editor: EditorInstance) => void;
  destroy?: () => void;
}

// 插件管理器
class PluginManager {
  private plugins: Map<string, EditorPlugin> = new Map();
  private editor: EditorInstance;
  
  constructor(editor: EditorInstance) {
    this.editor = editor;
  }
  
  // 注册插件
  register(plugin: EditorPlugin): void {
    if (this.plugins.has(plugin.id)) {
      throw new Error(`Plugin ${plugin.id} already registered`);
    }
    
    this.plugins.set(plugin.id, plugin);
    plugin.init(this.editor);
  }
  
  // 卸载插件
  unregister(pluginId: string): void {
    const plugin = this.plugins.get(pluginId);
    
    if (!plugin) return;
    
    if (plugin.destroy) {
      plugin.destroy();
    }
    
    this.plugins.delete(pluginId);
  }
  
  // 获取插件
  getPlugin(pluginId: string): EditorPlugin | undefined {
    return this.plugins.get(pluginId);
  }
}
```

### 4.2 自定义组件

支持用户创建和注册自定义组件：

```typescript
// 自定义组件注册
interface CustomComponentDefinition {
  type: string;
  name: string;
  category: string;
  icon?: string;
  defaultProps?: Record<string, any>;
  propDefinitions: PropDefinition[];
  renderer: ComponentRenderer;
}

// 组件注册示例
componentRegistry.registerCustomComponent({
  type: 'custom-card',
  name: '自定义卡片',
  category: '自定义组件',
  icon: 'card-icon',
  defaultProps: {
    title: '卡片标题',
    content: '卡片内容'
  },
  propDefinitions: [
    { name: 'title', type: 'string', label: '标题' },
    { name: 'content', type: 'text', label: '内容' }
  ],
  renderer: (props, children) => {
    // 自定义渲染逻辑
  }
});
```

## 下一步

继续阅读[编辑器核心](./03-编辑器核心.md)了解编辑器核心模块的详细设计。 